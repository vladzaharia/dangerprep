#!/bin/bash
# DangerPrep WiFi Connection Manager
# Changes WiFi connection to a new SSID with interactive prompts
# 
# Usage:
#   dp-wifi-change [OPTIONS]
#
# Options:
#   -h, --help       Show this help message
#   -v, --verbose    Enable verbose output
#   -i, --interface  Specify WiFi interface (optional)
#   -s, --ssid       Specify SSID (optional, will prompt if not provided)
#   -p, --password   Specify password (optional, will prompt if not provided)
#   --non-interactive  Run without prompts (requires --interface, --ssid, --password)
#
# Dependencies:
#   - nmcli (NetworkManager command line interface)
#   - gum (for enhanced UI, optional)

set -euo pipefail

# Script configuration
readonly SCRIPT_NAME="dp-wifi-change"
readonly SCRIPT_VERSION="1.0.0"
readonly LOG_FILE="/var/log/dp-wifi-change.log"
readonly LOCK_FILE_DEFAULT="/var/run/dp-wifi-change.lock"

# Actual lock file path (may be changed to fallback location)
ACTUAL_LOCK_FILE=""

# Default options
VERBOSE=false
NON_INTERACTIVE=false
SHOW_STATUS=false
INTERFACE=""
SSID=""
PASSWORD=""

# Colors for output
readonly RED='\033[0;31m'
readonly GREEN='\033[0;32m'
readonly YELLOW='\033[1;33m'
readonly BLUE='\033[0;34m'
readonly NC='\033[0m' # No Color

# Source shared utilities if available
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
SHARED_DIR="${SCRIPT_DIR}/shared"

if [[ -f "${SHARED_DIR}/gum-utils.sh" ]]; then
    # shellcheck source=scripts/shared/gum-utils.sh
    source "${SHARED_DIR}/gum-utils.sh"
    HAS_GUM_UTILS=true
else
    HAS_GUM_UTILS=false
fi

if [[ -f "${SHARED_DIR}/banner.sh" ]]; then
    # shellcheck source=scripts/shared/banner.sh
    source "${SHARED_DIR}/banner.sh"
    HAS_BANNER=true
else
    HAS_BANNER=false
fi

# Use enhanced logging from gum-utils if available, fallback to basic logging
if [[ "$HAS_GUM_UTILS" == "true" ]]; then
    # Set DEBUG environment variable for gum-utils debug logging
    [[ "$VERBOSE" == "true" ]] && export DEBUG=true

    # Use enhanced logging functions from gum-utils.sh
    # These are already defined in gum-utils.sh: log_info, log_warn, log_error, log_debug, log_success
    :
else
    # Fallback logging functions when gum-utils is not available
    log() {
        local level="$1"
        shift
        local message="$*"
        local timestamp
        timestamp=$(date '+%Y-%m-%d %H:%M:%S')

        # Log to file (with fallback for permission issues)
        if mkdir -p "$(dirname "${LOG_FILE}")" 2>/dev/null && echo "[${timestamp}] [${level}] ${message}" >> "${LOG_FILE}" 2>/dev/null; then
            : # Successfully logged to system log
        else
            # Fallback to user log directory
            local user_log_dir="${HOME}/.local/share/dangerprep/logs"
            local user_log_file
            user_log_file="${user_log_dir}/$(basename "${LOG_FILE}")"
            mkdir -p "${user_log_dir}" 2>/dev/null || true
            echo "[${timestamp}] [${level}] ${message}" >> "${user_log_file}" 2>/dev/null || true
        fi

        # Log to console with colors
        case "${level}" in
            "ERROR")
                echo -e "${RED}[ERROR]${NC} ${message}" >&2
                ;;
            "WARN")
                echo -e "${YELLOW}[WARN]${NC} ${message}" >&2
                ;;
            "INFO")
                echo -e "${GREEN}[INFO]${NC} ${message}"
                ;;
            "DEBUG")
                [[ "${VERBOSE}" == "true" ]] && echo -e "${BLUE}[DEBUG]${NC} ${message}"
                ;;
        esac
    }

    log_info() { log "INFO" "$@"; }
    log_warn() { log "WARN" "$@"; }
    log_error() { log "ERROR" "$@"; }
    log_debug() { log "DEBUG" "$@"; }
fi

# Error handling
error_exit() {
    log_error "$@"
    cleanup
    exit 1
}

# Cleanup function
cleanup() {
    [[ -n "${ACTUAL_LOCK_FILE}" ]] && [[ -f "${ACTUAL_LOCK_FILE}" ]] && rm -f "${ACTUAL_LOCK_FILE}"
}

# Trap cleanup on exit
trap cleanup EXIT

# Show help
show_help() {
    cat << EOF
DangerPrep WiFi Connection Manager v${SCRIPT_VERSION}

DESCRIPTION:
    Interactive tool to change WiFi connection to a new SSID. Automatically
    detects available WiFi interfaces and networks, then connects to the
    specified network with the provided credentials.

USAGE:
    ${SCRIPT_NAME} [OPTIONS]

OPTIONS:
    -h, --help           Show this help message and exit
    -v, --verbose        Enable verbose output and debugging
    -i, --interface      Specify WiFi interface (e.g., wlan0, wlp2s0)
    -s, --ssid           Specify SSID to connect to
    -p, --password       Specify WiFi password
    --status             Show current WiFi connection status
    --non-interactive    Run without prompts (requires all parameters)

EXAMPLES:
    ${SCRIPT_NAME}                                    # Interactive mode
    ${SCRIPT_NAME} --interface wlan0                 # Pre-select interface
    ${SCRIPT_NAME} --ssid "MyNetwork" --password "pass123"  # Pre-fill credentials
    ${SCRIPT_NAME} --status                          # Show current WiFi status
    ${SCRIPT_NAME} --non-interactive -i wlan0 -s "MyNetwork" -p "pass123"  # Fully automated

DEPENDENCIES:
    - nmcli (NetworkManager command line interface)
    - gum (for enhanced UI, optional)

LOGS:
    Operations are logged to: ${LOG_FILE}

EOF
}

#######################################
# Check for required system dependencies
# Globals:
#   None
# Arguments:
#   None
# Returns:
#   Exits with error if dependencies are missing and cannot be installed
#######################################
check_dependencies() {
    local deps=("nmcli")
    local missing_deps=()
    
    for dep in "${deps[@]}"; do
        if ! command -v "$dep" >/dev/null 2>&1; then
            missing_deps+=("$dep")
        fi
    done
    
    if [[ ${#missing_deps[@]} -gt 0 ]]; then
        log_warn "Missing dependencies: ${missing_deps[*]}"
        log_info "Installing missing packages..."
        
        # Install missing packages
        if command -v apt-get >/dev/null 2>&1; then
            apt-get update
            for dep in "${missing_deps[@]}"; do
                case "$dep" in
                    "nmcli")
                        apt-get install -y network-manager
                        ;;
                    *)
                        apt-get install -y "$dep"
                        ;;
                esac
            done
        else
            error_exit "Package manager not found. Please install: ${missing_deps[*]}"
        fi
    fi
    
    # Check if NetworkManager is running
    if ! systemctl is-active --quiet NetworkManager; then
        log_warn "NetworkManager is not running. Starting it..."
        systemctl start NetworkManager
    fi
    
    log_debug "All dependencies satisfied"
}

# Create lock file
create_lock() {
    local lock_file="${LOCK_FILE_DEFAULT}"

    # Try to create lock file, fallback to user directory if needed
    if ! echo "$$" > "${lock_file}" 2>/dev/null; then
        local user_lock_dir="${HOME}/.local/share/dangerprep/locks"
        mkdir -p "${user_lock_dir}" 2>/dev/null || true
        lock_file="${user_lock_dir}/$(basename "${LOCK_FILE_DEFAULT}")"
    fi

    if [[ -f "${lock_file}" ]]; then
        local pid
        pid=$(cat "${lock_file}" 2>/dev/null || echo "")
        if [[ -n "${pid}" ]] && [[ "${pid}" != "$$" ]] && kill -0 "${pid}" 2>/dev/null; then
            error_exit "Another instance is already running (PID: ${pid})"
        else
            [[ "${pid}" != "$$" ]] && log_warn "Removing stale lock file"
            rm -f "${lock_file}" 2>/dev/null || true
        fi
    fi

    if echo "$$" > "${lock_file}" 2>/dev/null; then
        # Update ACTUAL_LOCK_FILE variable to point to the actual lock file used
        ACTUAL_LOCK_FILE="${lock_file}"
        log_debug "Created lock file: ${ACTUAL_LOCK_FILE}"
    else
        log_warn "Could not create lock file, continuing without lock"
    fi
}

#######################################
# Get available WiFi interfaces from NetworkManager
# Globals:
#   None
# Arguments:
#   None
# Outputs:
#   Writes list of WiFi interfaces to stdout, one per line
# Returns:
#   0 on success
#######################################
get_wifi_interfaces() {
    local interfaces=()
    
    # Get WiFi interfaces from nmcli
    while IFS= read -r interface; do
        [[ -n "$interface" ]] && interfaces+=("$interface")
    done < <(nmcli -t -f DEVICE,TYPE device status | grep ":wifi$" | cut -d: -f1)
    
    if [[ ${#interfaces[@]} -eq 0 ]]; then
        error_exit "No WiFi interfaces found"
    fi
    
    printf '%s\n' "${interfaces[@]}"
}

#######################################
# Scan for available WiFi networks on an interface
# Globals:
#   None
# Arguments:
#   $1 - WiFi interface name
# Outputs:
#   Writes list of SSIDs to stdout, one per line
# Returns:
#   0 on success, 1 if no networks found
#######################################
scan_networks() {
    local interface="$1"

    log_info "Scanning for available networks on $interface..."
    
    # Rescan for networks
    nmcli device wifi rescan ifname "$interface" 2>/dev/null || true
    sleep 2
    
    # Get available networks
    local networks=()
    while IFS= read -r network; do
        [[ -n "$network" ]] && networks+=("$network")
    done < <(nmcli -t -f SSID device wifi list ifname "$interface" | grep -v "^$" | sort -u)
    
    if [[ ${#networks[@]} -eq 0 ]]; then
        log_warn "No networks found on $interface"
        return 1
    fi
    
    log_info "Found ${#networks[@]} networks"
    printf '%s\n' "${networks[@]}"
}

#######################################
# Connect to a WiFi network using NetworkManager
# Globals:
#   None
# Arguments:
#   $1 - WiFi interface name
#   $2 - SSID to connect to
#   $3 - WiFi password
# Returns:
#   0 on success, 1 on failure
#######################################
connect_wifi() {
    local interface="$1"
    local ssid="$2"
    local password="$3"

    log_info "Connecting to '$ssid' on interface '$interface'..."
    
    # Disconnect from current network first
    nmcli device disconnect "$interface" 2>/dev/null || true
    
    # Connect to WiFi network
    if nmcli device wifi connect "$ssid" password "$password" ifname "$interface" 2>&1; then
        log_info "Successfully connected to '$ssid'"
        return 0
    else
        log_error "Failed to connect to '$ssid'"
        return 1
    fi
}

# Verify connection
verify_connection() {
    local interface="$1"
    local expected_ssid="$2"

    log_info "Verifying connection..."

    # Wait a moment for connection to establish
    sleep 3

    # Check connection status
    local current_ssid
    current_ssid=$(nmcli -t -f active,ssid dev wifi | grep "^yes:" | cut -d: -f2)

    if [[ "$current_ssid" == "$expected_ssid" ]]; then
        log_info "✓ Successfully connected to '$expected_ssid'"

        # Get IP address
        local ip_address
        ip_address=$(nmcli -t -f IP4.ADDRESS dev show "$interface" | cut -d: -f2 | cut -d/ -f1)
        [[ -n "$ip_address" ]] && log_info "IP Address: $ip_address"

        return 0
    else
        log_error "✗ Connection verification failed"
        [[ -n "$current_ssid" ]] && log_error "Currently connected to: $current_ssid"
        return 1
    fi
}

# Show WiFi connection status
show_status() {
    echo "DangerPrep WiFi Connection Status"
    echo "================================="
    echo

    # Check NetworkManager status
    echo "Service Status:"
    if systemctl is-active --quiet NetworkManager; then
        echo "  NetworkManager: ${GREEN}Running${NC}"
    else
        echo "  NetworkManager: ${RED}Stopped${NC}"
        return 1
    fi

    echo

    # Get all WiFi interfaces
    local interfaces=()
    while IFS= read -r interface; do
        [[ -n "$interface" ]] && interfaces+=("$interface")
    done < <(nmcli -t -f DEVICE,TYPE device status | grep ":wifi$" | cut -d: -f1)

    if [[ ${#interfaces[@]} -eq 0 ]]; then
        echo "No WiFi interfaces found"
        return 1
    fi

    # Show status for each WiFi interface
    for interface in "${interfaces[@]}"; do
        echo "Interface: $interface"

        # Get interface state
        local state
        state=$(nmcli -t -f DEVICE,STATE device status | grep "^${interface}:" | cut -d: -f2)
        echo "  State: $state"

        # Get current connection if connected
        if [[ "$state" == "connected" ]]; then
            local current_ssid
            current_ssid=$(nmcli -t -f active,ssid dev wifi | grep "^yes:" | cut -d: -f2)
            [[ -n "$current_ssid" ]] && echo "  Connected to: $current_ssid"

            # Get IP address
            local ip_address
            ip_address=$(nmcli -t -f IP4.ADDRESS dev show "$interface" | cut -d: -f2 | cut -d/ -f1)
            [[ -n "$ip_address" ]] && echo "  IP Address: $ip_address"

            # Get signal strength
            local signal
            signal=$(nmcli -t -f IN-USE,SIGNAL dev wifi | grep "^\*:" | cut -d: -f2)
            [[ -n "$signal" ]] && echo "  Signal Strength: ${signal}%"
        fi

        echo
    done

    # Show available networks for the first interface
    if [[ ${#interfaces[@]} -gt 0 ]]; then
        local first_interface="${interfaces[0]}"
        echo "Available Networks (on $first_interface):"

        # Get available networks with signal strength
        local networks_info
        networks_info=$(nmcli -t -f SSID,SIGNAL,SECURITY dev wifi list ifname "$first_interface" 2>/dev/null | grep -v "^$" | sort -t: -k2 -nr | head -10)

        if [[ -n "$networks_info" ]]; then
            echo "  SSID                    Signal  Security"
            echo "  ----                    ------  --------"
            while IFS=: read -r ssid signal security; do
                [[ -n "$ssid" ]] && printf "  %-22s  %3s%%    %s\n" "$ssid" "$signal" "$security"
            done <<< "$networks_info"
        else
            echo "  No networks found"
        fi
    fi
}

# Main execution function
main() {
    # Parse command line arguments
    while [[ $# -gt 0 ]]; do
        case $1 in
            -h|--help)
                show_help
                exit 0
                ;;
            -v|--verbose)
                VERBOSE=true
                shift
                ;;
            -i|--interface)
                INTERFACE="$2"
                shift 2
                ;;
            -s|--ssid)
                SSID="$2"
                shift 2
                ;;
            -p|--password)
                PASSWORD="$2"
                shift 2
                ;;
            --status)
                SHOW_STATUS=true
                shift
                ;;
            --non-interactive)
                NON_INTERACTIVE=true
                shift
                ;;
            *)
                error_exit "Unknown option: $1. Use --help for usage information."
                ;;
        esac
    done

    # Show banner if available
    if [[ "$HAS_BANNER" == "true" ]]; then
        show_banner_with_title "WiFi Connection Manager" "network"
    else
        echo "DangerPrep WiFi Connection Manager v${SCRIPT_VERSION}"
        echo "================================================="
    fi

    # Handle status request
    if [[ "$SHOW_STATUS" == "true" ]]; then
        show_status
        exit 0
    fi

    # Check dependencies
    check_dependencies

    # Create lock file
    create_lock

    # Get WiFi interfaces if not specified
    if [[ -z "$INTERFACE" ]]; then
        local interfaces
        if ! interfaces=$(get_wifi_interfaces); then
            error_exit "Failed to get WiFi interfaces"
        fi

        local interfaces_array=()
        while IFS= read -r line; do
            interfaces_array+=("$line")
        done <<< "$interfaces"

        if [[ ${#interfaces_array[@]} -eq 1 ]]; then
            INTERFACE="${interfaces_array[0]}"
            log_info "Using WiFi interface: $INTERFACE"
        else
            if [[ "$NON_INTERACTIVE" == "true" ]]; then
                error_exit "Multiple WiFi interfaces found. Please specify one with --interface"
            fi

            if [[ "$HAS_GUM_UTILS" == "true" ]]; then
                INTERFACE=$(enhanced_choose "Select WiFi interface:" "${interfaces_array[@]}")
            else
                echo "Available WiFi interfaces:"
                for i in "${!interfaces_array[@]}"; do
                    echo "$((i+1)). ${interfaces_array[i]}"
                done
                read -r -p "Select interface (1-${#interfaces_array[@]}): " choice
                INTERFACE="${interfaces_array[$((choice-1))]}"
            fi

            [[ -z "$INTERFACE" ]] && error_exit "No interface selected"
        fi
    fi

    # Detect current WiFi connection
    local current_ssid=""
    local current_interface=""
    current_ssid=$(nmcli -t -f active,ssid dev wifi 2>/dev/null | grep "^yes:" | cut -d: -f2)
    if [[ -n "$current_ssid" ]]; then
        # Find which interface is connected
        for iface in $(nmcli -t -f DEVICE,TYPE device status | grep ":wifi$" | cut -d: -f1); do
            local iface_state
            iface_state=$(nmcli -t -f DEVICE,STATE device status | grep "^${iface}:" | cut -d: -f2)
            if [[ "$iface_state" == "connected" ]]; then
                current_interface="$iface"
                break
            fi
        done

        log_info "Currently connected to '$current_ssid' on interface '$current_interface'"
    fi

    # Scan for networks and get SSID if not specified
    if [[ -z "$SSID" ]]; then
        if [[ "$NON_INTERACTIVE" == "true" ]]; then
            error_exit "SSID not specified. Use --ssid in non-interactive mode"
        fi

        local networks
        if ! networks=$(scan_networks "$INTERFACE"); then
            error_exit "Failed to scan for networks"
        fi

        local networks_array=()
        while IFS= read -r line; do
            networks_array+=("$line")
        done <<< "$networks"

        if [[ "$HAS_GUM_UTILS" == "true" ]]; then
            SSID=$(enhanced_choose "Select network to connect to:" "${networks_array[@]}")
        else
            echo "Available networks:"
            for i in "${!networks_array[@]}"; do
                echo "$((i+1)). ${networks_array[i]}"
            done
            read -r -p "Select network (1-${#networks_array[@]}): " choice
            SSID="${networks_array[$((choice-1))]}"
        fi

        [[ -z "$SSID" ]] && error_exit "No network selected"
    fi

    # Get password if not specified
    if [[ -z "$PASSWORD" ]]; then
        if [[ "$NON_INTERACTIVE" == "true" ]]; then
            error_exit "Password not specified. Use --password in non-interactive mode"
        fi

        if [[ "$HAS_GUM_UTILS" == "true" ]]; then
            PASSWORD=$(enhanced_password "Enter WiFi password for '$SSID':")
        else
            read -r -s -p "Enter WiFi password for '$SSID': " PASSWORD
            echo
        fi

        [[ -z "$PASSWORD" ]] && error_exit "No password provided"
    fi

    # Connect to WiFi
    if connect_wifi "$INTERFACE" "$SSID" "$PASSWORD"; then
        if verify_connection "$INTERFACE" "$SSID"; then
            log_info "WiFi connection change completed successfully!"
        else
            error_exit "Connection verification failed"
        fi
    else
        error_exit "Failed to connect to WiFi network"
    fi
}

# Run main function if script is executed directly
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    main "$@"
fi
