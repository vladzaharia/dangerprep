#!/bin/bash
# DangerPrep System Update Utility
# Updates git repository, Docker containers, and system packages
# 
# Usage:
#   dp-update [OPTIONS]
#
# Options:
#   -h, --help       Show this help message
#   -v, --verbose    Enable verbose output
#   -d, --dry-run    Show what would be done without executing
#   --skip-git       Skip git repository update
#   --skip-apt       Skip system package updates
#
# Dependencies:
#   - docker
#   - docker compose
#   - git
#   - apt
#   - gum (for enhanced UI)

set -uo pipefail

# Script configuration
readonly SCRIPT_NAME="dp-update"
readonly SCRIPT_VERSION="1.0.0"
readonly DOCKER_ROOT="${DOCKER_ROOT:-/dangerprep/docker}"
readonly GIT_ROOT="${GIT_ROOT:-/dangerprep}"
readonly LOG_FILE="/var/log/dp-update.log"
LOCK_FILE="/var/run/dp-update.lock"

# Default options
VERBOSE=false
DRY_RUN=false
SKIP_GIT=false
SKIP_APT=false

# Colors for output
readonly RED='\033[0;31m'
readonly GREEN='\033[0;32m'
readonly YELLOW='\033[1;33m'
readonly BLUE='\033[0;34m'
readonly NC='\033[0m' # No Color

# Source shared utilities if available
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
SHARED_DIR="${SCRIPT_DIR}/../shared"

if [[ -f "${SHARED_DIR}/gum-utils.sh" ]]; then
    source "${SHARED_DIR}/gum-utils.sh"
    HAS_GUM_UTILS=true
else
    HAS_GUM_UTILS=false
fi

if [[ -f "${SHARED_DIR}/banner.sh" ]]; then
    source "${SHARED_DIR}/banner.sh"
    HAS_BANNER=true
else
    HAS_BANNER=false
fi

if [[ -f "${SHARED_DIR}/lock-utils.sh" ]]; then
    source "${SHARED_DIR}/lock-utils.sh"
    HAS_LOCK_UTILS=true
else
    HAS_LOCK_UTILS=false
fi

# Arrays to track compose files that need restart
declare -a COMPOSE_FILES_TO_RESTART=()

# Logging functions
log_debug() {
    [[ "$VERBOSE" == "true" ]] && echo -e "${BLUE}[DEBUG]${NC} $*" >&2
    echo "$(date '+%Y-%m-%d %H:%M:%S') [DEBUG] $*" >> "$LOG_FILE" 2>/dev/null || true
}

log_info() {
    echo -e "${GREEN}[INFO]${NC} $*"
    echo "$(date '+%Y-%m-%d %H:%M:%S') [INFO] $*" >> "$LOG_FILE" 2>/dev/null || true
}

log_warn() {
    echo -e "${YELLOW}[WARN]${NC} $*" >&2
    echo "$(date '+%Y-%m-%d %H:%M:%S') [WARN] $*" >> "$LOG_FILE" 2>/dev/null || true
}

log_error() {
    echo -e "${RED}[ERROR]${NC} $*" >&2
    echo "$(date '+%Y-%m-%d %H:%M:%S') [ERROR] $*" >> "$LOG_FILE" 2>/dev/null || true
}

error_exit() {
    log_error "$1"
    exit 1
}

# Check if running as root
check_root() {
    if [[ $EUID -ne 0 ]]; then
        error_exit "This script must be run as root (use sudo)"
    fi
}

# Show help message
show_help() {
    cat << EOF
$SCRIPT_NAME v$SCRIPT_VERSION

DESCRIPTION:
    Updates the DangerPrep system by pulling git changes, updating Docker
    containers, and upgrading system packages. Only processes containers
    that are currently running.

USAGE:
    $SCRIPT_NAME [OPTIONS]

OPTIONS:
    -h, --help       Show this help message and exit
    -v, --verbose    Enable verbose output and debugging
    -d, --dry-run    Show what would be done without executing
    --skip-git       Skip git repository update step
    --skip-apt       Skip system package update step

EXAMPLES:
    $SCRIPT_NAME                    # Full system update
    $SCRIPT_NAME --verbose          # Update with detailed output
    $SCRIPT_NAME --dry-run          # Show what would be updated
    $SCRIPT_NAME --skip-apt         # Update without system packages

REQUIREMENTS:
    • Root privileges (run with sudo)
    • Git repository at $GIT_ROOT
    • Docker and Docker Compose
    • Internet connection for updates

EOF
}

# Check dependencies
check_dependencies() {
    local deps=("docker" "git" "apt")
    local missing_deps=()
    
    for dep in "${deps[@]}"; do
        if ! command -v "$dep" >/dev/null 2>&1; then
            missing_deps+=("$dep")
        fi
    done
    
    # Check for docker compose (V2 syntax)
    if ! docker compose version >/dev/null 2>&1; then
        missing_deps+=("docker compose")
    fi
    
    if [[ ${#missing_deps[@]} -gt 0 ]]; then
        error_exit "Missing dependencies: ${missing_deps[*]}"
    fi
    
    # Check if Docker daemon is running
    if ! docker info >/dev/null 2>&1; then
        error_exit "Docker daemon is not running. Please start Docker first."
    fi
    
    log_debug "All dependencies satisfied"
}

# Find all compose files in the docker directory
find_compose_files() {
    local compose_files=()
    
    if [[ ! -d "$DOCKER_ROOT" ]]; then
        log_warn "Docker root directory not found: $DOCKER_ROOT, skipping Docker updates"
        return 1
    fi
    
    while IFS= read -r -d '' file; do
        compose_files+=("$file")
    done < <(find "$DOCKER_ROOT" -name "compose.yml" -type f -print0 2>/dev/null)
    
    if [[ ${#compose_files[@]} -eq 0 ]]; then
        log_warn "No compose.yml files found in $DOCKER_ROOT, skipping Docker updates"
        return 1
    fi
    
    log_debug "Found ${#compose_files[@]} compose files"
    printf '%s\n' "${compose_files[@]}"
}

# Check if any containers from a compose file are running
check_running_containers() {
    local compose_file="$1"
    local compose_dir
    compose_dir="$(dirname "$compose_file")"
    
    log_debug "Checking running containers for: $compose_file"
    
    # Get running services for this compose file
    local running_services
    if running_services=$(cd "$compose_dir" && docker compose ps --services --filter status=running 2>/dev/null); then
        if [[ -n "$running_services" ]]; then
            log_debug "Running services in $compose_dir: $running_services"
            echo "$running_services"
            return 0
        fi
    fi
    
    log_debug "No running containers found for: $compose_file"
    return 1
}

# Analyze compose file to determine which services use build vs image
analyze_compose_services() {
    local compose_file="$1"
    local running_services="$2"
    
    log_debug "Analyzing services in: $compose_file"
    
    local services_with_build=()
    local services_with_image=()
    
    # Read running services into array
    local -a running_array
    while IFS= read -r service; do
        [[ -n "$service" ]] && running_array+=("$service")
    done <<< "$running_services"
    
    # Parse compose file for each running service
    for service in "${running_array[@]}"; do
        if grep -q "^[[:space:]]*${service}:" "$compose_file"; then
            # Check if service has build configuration
            if sed -n "/^[[:space:]]*${service}:/,/^[[:space:]]*[^[:space:]]/p" "$compose_file" | grep -q "^[[:space:]]*build:"; then
                services_with_build+=("$service")
                log_debug "Service '$service' uses build"
            # Check if service has image configuration
            elif sed -n "/^[[:space:]]*${service}:/,/^[[:space:]]*[^[:space:]]/p" "$compose_file" | grep -q "^[[:space:]]*image:"; then
                services_with_image+=("$service")
                log_debug "Service '$service' uses image"
            fi
        fi
    done
    
    # Return results via global variables (bash limitation workaround)
    ANALYZED_BUILD_SERVICES=("${services_with_build[@]}")
    ANALYZED_IMAGE_SERVICES=("${services_with_image[@]}")
}

# Update git repository
update_git_repo() {
    if [[ "$SKIP_GIT" == "true" ]]; then
        log_info "Skipping git repository update (--skip-git specified)"
        return 0
    fi
    
    log_info "Updating git repository: $GIT_ROOT"
    
    if [[ ! -d "$GIT_ROOT" ]]; then
        log_warn "Git root directory not found: $GIT_ROOT, skipping git update"
        return 0
    fi

    if [[ ! -d "$GIT_ROOT/.git" ]]; then
        log_warn "Not a git repository: $GIT_ROOT, skipping git update"
        return 0
    fi
    
    if [[ "$DRY_RUN" == "true" ]]; then
        log_info "DRY RUN: Would run 'git pull' in $GIT_ROOT"
        return 0
    fi
    
    local git_output
    if git_output=$(cd "$GIT_ROOT" && git pull 2>&1); then
        log_info "Git pull completed successfully"
        log_debug "Git output: $git_output"
    else
        log_error "Git pull failed: $git_output, continuing with other updates"
        return 0
    fi
}

# Process a compose file for updates
process_compose_file() {
    local compose_file="$1"
    local compose_dir
    compose_dir="$(dirname "$compose_file")"

    log_debug "Processing compose file: $compose_file"

    # Check if any containers are running
    local running_services
    if ! running_services=$(check_running_containers "$compose_file"); then
        log_debug "No running containers, skipping: $compose_file"
        return 0
    fi

    log_info "Processing running containers in: $(basename "$compose_dir")"

    # Analyze services for build vs image
    analyze_compose_services "$compose_file" "$running_services"

    local needs_restart=false

    # Handle services with build configuration
    if [[ ${#ANALYZED_BUILD_SERVICES[@]} -gt 0 ]]; then
        log_info "Building containers with Dockerfile: ${ANALYZED_BUILD_SERVICES[*]}"

        if [[ "$DRY_RUN" == "true" ]]; then
            log_info "DRY RUN: Would run 'docker compose build' for services: ${ANALYZED_BUILD_SERVICES[*]}"
        else
            local build_cmd="docker compose build"
            for service in "${ANALYZED_BUILD_SERVICES[@]}"; do
                build_cmd+=" $service"
            done

            if [[ "$HAS_GUM_UTILS" == "true" ]]; then
                if enhanced_spin "Building $(basename "$compose_dir")" bash -c "cd '$compose_dir' && $build_cmd"; then
                    log_info "Build completed successfully"
                    needs_restart=true
                else
                    log_error "Build failed for: $compose_file, skipping to next service"
                    return 0
                fi
            else
                if (cd "$compose_dir" && eval "$build_cmd"); then
                    log_info "Build completed successfully"
                    needs_restart=true
                else
                    log_error "Build failed for: $compose_file, skipping to next service"
                    return 0
                fi
            fi
        fi
    fi

    # Handle services with image configuration
    if [[ ${#ANALYZED_IMAGE_SERVICES[@]} -gt 0 ]]; then
        log_info "Pulling external images: ${ANALYZED_IMAGE_SERVICES[*]}"

        if [[ "$DRY_RUN" == "true" ]]; then
            log_info "DRY RUN: Would run 'docker compose pull' for services: ${ANALYZED_IMAGE_SERVICES[*]}"
        else
            local pull_cmd="docker compose pull"
            for service in "${ANALYZED_IMAGE_SERVICES[@]}"; do
                pull_cmd+=" $service"
            done

            if [[ "$HAS_GUM_UTILS" == "true" ]]; then
                if enhanced_spin "Pulling $(basename "$compose_dir")" bash -c "cd '$compose_dir' && $pull_cmd"; then
                    log_info "Pull completed successfully"
                    needs_restart=true
                else
                    log_error "Pull failed for: $compose_file, skipping to next service"
                    return 0
                fi
            else
                if (cd "$compose_dir" && eval "$pull_cmd"); then
                    log_info "Pull completed successfully"
                    needs_restart=true
                else
                    log_error "Pull failed for: $compose_file, skipping to next service"
                    return 0
                fi
            fi
        fi
    fi

    # Track compose files that need restart
    if [[ "$needs_restart" == "true" ]]; then
        COMPOSE_FILES_TO_RESTART+=("$compose_file")
        log_debug "Added to restart list: $compose_file"
    fi
}

# Restart updated services
restart_updated_services() {
    if [[ ${#COMPOSE_FILES_TO_RESTART[@]} -eq 0 ]]; then
        log_info "No services need restarting"
        return 0
    fi

    log_info "Restarting ${#COMPOSE_FILES_TO_RESTART[@]} updated service(s)"

    for compose_file in "${COMPOSE_FILES_TO_RESTART[@]}"; do
        local compose_dir
        compose_dir="$(dirname "$compose_file")"

        log_info "Restarting services in: $(basename "$compose_dir")"

        if [[ "$DRY_RUN" == "true" ]]; then
            log_info "DRY RUN: Would run 'docker compose up -d' in $compose_dir"
        else
            if [[ "$HAS_GUM_UTILS" == "true" ]]; then
                if enhanced_spin "Restarting $(basename "$compose_dir")" bash -c "cd '$compose_dir' && docker compose up -d"; then
                    log_info "Restart completed successfully"
                else
                    log_error "Restart failed for: $compose_file, continuing with next service"
                fi
            else
                if (cd "$compose_dir" && docker compose up -d); then
                    log_info "Restart completed successfully"
                else
                    log_error "Restart failed for: $compose_file, continuing with next service"
                fi
            fi
        fi
    done
}

# Update system packages
update_system_packages() {
    if [[ "$SKIP_APT" == "true" ]]; then
        log_info "Skipping system package updates (--skip-apt specified)"
        return 0
    fi

    log_info "Updating system packages"

    if [[ "$DRY_RUN" == "true" ]]; then
        log_info "DRY RUN: Would run 'apt update && apt upgrade -y'"
        return 0
    fi

    # Update package lists
    if [[ "$HAS_GUM_UTILS" == "true" ]]; then
        if enhanced_spin "Updating package lists" apt update; then
            log_info "Package list update completed"
        else
            log_error "Failed to update package lists, skipping package upgrade"
            return 0
        fi
    else
        if apt update; then
            log_info "Package list update completed"
        else
            log_error "Failed to update package lists, skipping package upgrade"
            return 0
        fi
    fi

    # Upgrade packages
    if [[ "$HAS_GUM_UTILS" == "true" ]]; then
        if enhanced_spin "Upgrading packages" apt upgrade -y; then
            log_info "Package upgrade completed"
        else
            log_error "Failed to upgrade packages, continuing"
            return 0
        fi
    else
        if apt upgrade -y; then
            log_info "Package upgrade completed"
        else
            log_error "Failed to upgrade packages, continuing"
            return 0
        fi
    fi
}

# Cleanup function
cleanup() {
    log_debug "Performing cleanup..."

    # Release lock file if using lock-utils
    if [[ -n "${LOCK_FD:-}" && "$HAS_LOCK_UTILS" == "true" ]]; then
        release_lock "${LOCK_FD}"
        log_debug "Released lock file"
    fi
}

# Trap for cleanup
trap cleanup EXIT INT TERM

# Parse command line arguments
parse_arguments() {
    while [[ $# -gt 0 ]]; do
        case $1 in
            -h|--help)
                show_help
                exit 0
                ;;
            -v|--verbose)
                VERBOSE=true
                shift
                ;;
            -d|--dry-run)
                DRY_RUN=true
                shift
                ;;
            --skip-git)
                SKIP_GIT=true
                shift
                ;;
            --skip-apt)
                SKIP_APT=true
                shift
                ;;
            *)
                error_exit "Unknown option: $1. Use --help for usage information."
                ;;
        esac
    done
}

# Main execution function
main() {
    # Parse command line arguments
    parse_arguments "$@"

    # Show banner if available
    if [[ "$HAS_BANNER" == "true" ]]; then
        show_banner_with_title "System Update" "update" "$SCRIPT_NAME v$SCRIPT_VERSION"
    else
        log_info "$SCRIPT_NAME v$SCRIPT_VERSION - DangerPrep System Update"
    fi

    # Check root privileges
    check_root

    # Check dependencies
    check_dependencies

    # Create lock file if lock-utils available
    if [[ "$HAS_LOCK_UTILS" == "true" ]]; then
        LOCK_FD=""
        if ! acquire_lock "${LOCK_FILE}" "LOCK_FD"; then
            error_exit "Another instance is already running or failed to acquire lock"
        fi
        log_debug "Acquired lock: ${LOCK_FILE} (FD: ${LOCK_FD})"
    fi

    # Log execution details
    log_info "Starting system update process..."
    log_info "Docker root: $DOCKER_ROOT"
    log_info "Git root: $GIT_ROOT"
    log_info "Verbose mode: $VERBOSE"
    log_info "Dry run mode: $DRY_RUN"
    log_info "Skip git: $SKIP_GIT"
    log_info "Skip apt: $SKIP_APT"

    # Update git repository
    if ! update_git_repo; then
        log_warn "Git repository update failed, continuing with Docker updates"
    fi

    # Find all compose files
    local compose_files_array=()
    local compose_files_output
    if compose_files_output=$(find_compose_files); then
        while IFS= read -r file; do
            [[ -n "$file" ]] && compose_files_array+=("$file")
        done <<< "$compose_files_output"
    else
        log_warn "No compose files found, skipping Docker updates"
    fi

    # Process each compose file
    if [[ ${#compose_files_array[@]} -gt 0 ]]; then
        log_info "Processing ${#compose_files_array[@]} compose file(s)"

        local success_count=0
        local failure_count=0

        for compose_file in "${compose_files_array[@]}"; do
            if process_compose_file "$compose_file"; then
                ((success_count++))
            else
                ((failure_count++))
                log_warn "Failed to process: $compose_file"
            fi
        done

        log_info "Compose processing completed: $success_count successful, $failure_count failed"

        # Restart updated services
        restart_updated_services
    fi

    # Update system packages
    update_system_packages

    log_info "System update completed successfully"
}

# Run main function with all arguments
main "$@"
