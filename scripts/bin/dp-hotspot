#!/bin/bash
# DangerPrep WiFi Hotspot Setup
# Creates a complete WiFi hotspot with DHCP, DNS, forwarding, and firewall rules
# 
# Usage:
#   dangerprep-wifi-hotspot [OPTIONS]
#
# Options:
#   -h, --help       Show this help message
#   -v, --verbose    Enable verbose output
#   -d, --disable    Disable and remove hotspot
#   -s, --status     Show hotspot status
#   --non-interactive  Run without prompts (uses defaults)
#
# Dependencies:
#   - hostapd (WiFi Access Point daemon)
#   - dnsmasq (DHCP and DNS server)
#   - iptables (firewall rules)
#   - systemd (service management)

set -euo pipefail

# Script configuration
readonly SCRIPT_NAME="dp-wifi-hotspot"
readonly SCRIPT_VERSION="1.0.0"
readonly LOCK_FILE_DEFAULT="/var/run/dp-wifi-hotspot.lock"

# Log file (not readonly so it can be exported)
LOG_FILE="/var/log/dp-wifi-hotspot.log"

# Lock file descriptor (will be set by acquire_lock)
LOCK_FD=""

# Backup file for iptables rules
IPTABLES_BACKUP="/var/lib/dangerprep/iptables-backup.rules"

# Configuration files
readonly HOSTAPD_CONF="/etc/hostapd/hostapd.conf"
readonly DNSMASQ_CONF="/etc/dnsmasq.d/dangerprep-hotspot.conf"
readonly SYSTEMD_RESOLVED_CONF="/etc/systemd/resolved.conf"
readonly SYSCTL_CONF="/etc/sysctl.d/99-dangerprep-hotspot.conf"

# Default hotspot configuration
readonly DEFAULT_SSID="DangerPrep-Hotspot"
readonly DEFAULT_PASSWORD="dangerprep123"
readonly DEFAULT_INTERFACE="wlan0"
readonly DEFAULT_IP="192.168.4.1"
readonly DEFAULT_DHCP_START="192.168.4.10"
readonly DEFAULT_DHCP_END="192.168.4.50"
readonly DEFAULT_CHANNEL="7"

# Options
VERBOSE=false
DISABLE_HOTSPOT=false
SHOW_STATUS=false
NON_INTERACTIVE=false

# Colors for output
readonly RED='\033[0;31m'
readonly GREEN='\033[0;32m'
readonly YELLOW='\033[1;33m'
readonly BLUE='\033[0;34m'
readonly NC='\033[0m' # No Color

# Source shared utilities if available
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
SHARED_DIR="${SCRIPT_DIR}/../shared"

# Source shared utilities
HAS_GUM_UTILS=false
HAS_BANNER=false

if [[ -f "${SHARED_DIR}/gum-utils.sh" ]]; then
    # shellcheck source=scripts/shared/gum-utils.sh
    source "${SHARED_DIR}/gum-utils.sh"
    HAS_GUM_UTILS=true
fi

if [[ -f "${SHARED_DIR}/banner.sh" ]]; then
    # shellcheck source=scripts/shared/banner.sh
    source "${SHARED_DIR}/banner.sh"
    HAS_BANNER=true
fi

# Source validation utilities
if [[ -f "${SHARED_DIR}/validation-utils.sh" ]]; then
    # shellcheck source=scripts/shared/validation-utils.sh
    source "${SHARED_DIR}/validation-utils.sh"
fi

# Source network utilities
if [[ -f "${SHARED_DIR}/network-utils.sh" ]]; then
    # shellcheck source=scripts/shared/network-utils.sh
    source "${SHARED_DIR}/network-utils.sh"
fi

# Source lock utilities
if [[ -f "${SHARED_DIR}/lock-utils.sh" ]]; then
    # shellcheck source=scripts/shared/lock-utils.sh
    source "${SHARED_DIR}/lock-utils.sh"
fi

# Source firewall utilities
if [[ -f "${SHARED_DIR}/firewall-utils.sh" ]]; then
    # shellcheck source=scripts/shared/firewall-utils.sh
    source "${SHARED_DIR}/firewall-utils.sh"
fi

# Setup logging - will be configured after argument parsing
setup_logging() {
    # Set DEBUG environment variable for gum-utils debug logging
    [[ "$VERBOSE" == "true" ]] && export DEBUG=true

    # Set LOG_FILE for gum-utils file logging
    export LOG_FILE="${LOG_FILE}"
}

# Error handling
error_exit() {
    log_error "$@"
    cleanup
    exit 1
}

# Cleanup function
cleanup() {
    if [[ -n "${LOCK_FD}" ]]; then
        release_lock "${LOCK_FD}"
    fi
}

# Handle interrupt signal (Ctrl-C)
handle_interrupt() {
    echo
    echo "Received interrupt signal (Ctrl+C). Cleaning up and exiting..." >&2
    cleanup
    exit 130
}

# Handle termination signal
handle_termination() {
    echo
    echo "Received termination signal. Cleaning up and exiting..." >&2
    cleanup
    exit 143
}

# Trap cleanup on exit and interrupt
trap cleanup EXIT
trap handle_interrupt INT SIGINT
trap handle_termination TERM SIGTERM

# Show help
show_help() {
    cat << EOF
DangerPrep WiFi Hotspot Setup v${SCRIPT_VERSION}

DESCRIPTION:
    Sets up a complete WiFi hotspot with DHCP, DNS, IP forwarding, and firewall
    rules. Handles systemd-resolved conflicts and provides a fully functional
    access point for emergency networking scenarios.

USAGE:
    ${SCRIPT_NAME} [OPTIONS]

OPTIONS:
    -h, --help              Show this help message and exit
    -v, --verbose           Enable verbose output and debugging
    -d, --disable           Disable and remove hotspot configuration
    -s, --status            Show current hotspot status
    --non-interactive       Run without prompts (uses default configuration)

EXAMPLES:
    ${SCRIPT_NAME}                    # Interactive setup
    ${SCRIPT_NAME} --verbose          # Setup with detailed output
    ${SCRIPT_NAME} --status           # Check hotspot status
    ${SCRIPT_NAME} --disable          # Remove hotspot configuration
    ${SCRIPT_NAME} --non-interactive  # Setup with defaults

DEFAULT CONFIGURATION:
    SSID: ${DEFAULT_SSID}
    Password: ${DEFAULT_PASSWORD}
    Interface: ${DEFAULT_INTERFACE}
    IP Address: ${DEFAULT_IP}
    DHCP Range: ${DEFAULT_DHCP_START} - ${DEFAULT_DHCP_END}
    Channel: ${DEFAULT_CHANNEL}

DEPENDENCIES:
    - hostapd (WiFi Access Point daemon)
    - dnsmasq (DHCP and DNS server)
    - iptables (firewall and NAT rules)
    - systemd (service management)

LOGS:
    Operations are logged to: ${LOG_FILE}

NOTES:
    - Requires root privileges
    - Modifies system network configuration
    - Configures systemd-resolved to avoid port conflicts
    - Sets up IP forwarding and NAT rules

EOF
}

#######################################
# Check if script is running with root privileges
# Globals:
#   EUID
# Arguments:
#   None
# Returns:
#   Exits with error if not running as root
#######################################
check_root() {
    if [[ ${EUID} -ne 0 ]]; then
        error_exit "This script must be run as root. Use: sudo ${0}"
    fi
}

#######################################
# Check for required system dependencies
# Globals:
#   None
# Arguments:
#   None
# Returns:
#   Exits with error if dependencies are missing and cannot be installed
#######################################
check_dependencies() {
    local deps=("hostapd" "dnsmasq" "iptables" "systemctl")
    local missing_deps=()
    
    for dep in "${deps[@]}"; do
        if ! command -v "$dep" >/dev/null 2>&1; then
            missing_deps+=("$dep")
        fi
    done
    
    if [[ ${#missing_deps[@]} -gt 0 ]]; then
        log_warn "Missing dependencies: ${missing_deps[*]}"
        log_info "Installing missing packages..."
        
        # Install missing packages
        if command -v apt-get >/dev/null 2>&1; then
            apt-get update
            for dep in "${missing_deps[@]}"; do
                case "$dep" in
                    "systemctl")
                        # systemctl is part of systemd, usually already installed
                        continue
                        ;;
                    *)
                        apt-get install -y "$dep"
                        ;;
                esac
            done
        else
            error_exit "Package manager not found. Please install: ${missing_deps[*]}"
        fi
    fi
    
    log_debug "All dependencies satisfied"
}

#######################################
# Create lock file using atomic locking
# Globals:
#   LOCK_FILE_DEFAULT, LOCK_FD
# Returns:
#   0 on success, exits on failure
#######################################
create_lock() {
    if ! acquire_lock "${LOCK_FILE_DEFAULT}" "LOCK_FD"; then
        error_exit "Failed to acquire lock. Another instance may be running."
    fi

    log_debug "Acquired lock (FD: ${LOCK_FD})"
}

#######################################
# Get available WiFi interfaces that support AP mode
# Uses check_ap_mode_support from network-utils for reliable detection
# Globals:
#   None
# Arguments:
#   None
# Outputs:
#   Writes list of WiFi interfaces to stdout, one per line
# Returns:
#   0 on success, 1 if no interfaces found
#######################################
get_wifi_interfaces() {
    local interfaces=()

    # Get all wireless interfaces
    while IFS= read -r iface; do
        if [[ -n "${iface}" ]]; then
            # Check if interface supports AP mode using network-utils
            if check_ap_mode_support "${iface}"; then
                interfaces+=("${iface}")
                log_debug "Interface ${iface} supports AP mode"
            else
                log_debug "Interface ${iface} does not support AP mode"
            fi
        fi
    done < <(iw dev 2>/dev/null | grep Interface | awk '{print $2}')

    # Fallback: get all wireless interfaces if iw failed
    if [[ ${#interfaces[@]} -eq 0 ]]; then
        log_debug "Falling back to glob-based interface detection"
        for iface_path in /sys/class/net/wl* /sys/class/net/wlan*; do
            if [[ -e "${iface_path}" ]]; then
                local iface
                iface=$(basename "${iface_path}")
                if check_ap_mode_support "${iface}"; then
                    interfaces+=("${iface}")
                fi
            fi
        done
    fi

    if [[ ${#interfaces[@]} -eq 0 ]]; then
        return 1
    fi

    printf '%s\n' "${interfaces[@]}"
}

#######################################
# Get actual values from running hotspot system
# Globals:
#   None
# Arguments:
#   None
# Outputs:
#   Writes actual values to stdout in format: interface ssid channel ip
# Returns:
#   0 if values found, 1 otherwise
#######################################
get_actual_hotspot_values() {
    local actual_interface=""
    local actual_ssid=""
    local actual_channel=""
    local actual_ip=""

    # Get interface from running hostapd process (don't rely on systemctl)
    actual_interface=$(ps aux | grep '[h]ostapd' | grep -oP '\-i\s+\K\w+' 2>/dev/null || echo "")
    if [[ -z "$actual_interface" ]]; then
        # Try alternative method: check hostapd config being used
        actual_interface=$(ps aux | grep '[h]ostapd' | grep -oP '/etc/hostapd/\S+' | head -1 | xargs grep "^interface=" 2>/dev/null | cut -d= -f2 || echo "")
    fi

    # Get values from interface if we found it
    if [[ -n "$actual_interface" ]] && ip link show "$actual_interface" &>/dev/null 2>&1; then
        # Get SSID
        actual_ssid=$(iw dev "$actual_interface" info 2>/dev/null | grep ssid | awk '{$1=""; print $0}' | xargs || echo "")

        # Get channel
        actual_channel=$(iw dev "$actual_interface" info 2>/dev/null | grep channel | awk '{print $2}' || echo "")

        # Get IP address
        actual_ip=$(ip addr show "$actual_interface" 2>/dev/null | grep "inet " | awk '{print $2}' | cut -d/ -f1 || echo "")
    fi

    # Return values
    echo "$actual_interface"
    echo "$actual_ssid"
    echo "$actual_channel"
    echo "$actual_ip"

    # Return success if we found at least an interface
    if [[ -n "$actual_interface" ]]; then
        return 0
    else
        return 1
    fi
}

#######################################
# Get hotspot configuration from user or use existing/defaults
# Globals:
#   HOSTAPD_CONF
#   DEFAULT_SSID, DEFAULT_PASSWORD, DEFAULT_INTERFACE, DEFAULT_IP
#   DEFAULT_DHCP_START, DEFAULT_DHCP_END, DEFAULT_CHANNEL
#   NON_INTERACTIVE, HAS_GUM_UTILS
# Arguments:
#   None
# Outputs:
#   Writes configuration values to stdout in format: ssid password interface ip dhcp_start dhcp_end channel
# Returns:
#   0 on success
#######################################
get_hotspot_config() {
    local config=()

    # Always try to get actual values from running system first (don't rely on systemctl)
    local actual_values=()
    local has_actual_values=false

    log_debug "Attempting to read actual values from running system..."
    while IFS= read -r line; do
        actual_values+=("$line")
    done < <(get_actual_hotspot_values)

    if [[ ${#actual_values[@]} -eq 4 ]] && [[ -n "${actual_values[0]}" ]]; then
        has_actual_values=true
        log_debug "Successfully read actual values from running system"
    else
        log_debug "No actual values found, will use config or defaults"
    fi

    # Check for existing hotspot configuration from files
    local existing_ssid=""
    local existing_interface=""
    local existing_channel=""
    local existing_ip=""
    local existing_dhcp_start=""
    local existing_dhcp_end=""
    local has_existing_config=false

    if [[ -f "$HOSTAPD_CONF" ]]; then
        existing_ssid=$(grep "^ssid=" "$HOSTAPD_CONF" 2>/dev/null | cut -d= -f2 || echo "")
        existing_interface=$(grep "^interface=" "$HOSTAPD_CONF" 2>/dev/null | cut -d= -f2 || echo "")
        existing_channel=$(grep "^channel=" "$HOSTAPD_CONF" 2>/dev/null | cut -d= -f2 || echo "")
    fi

    # Read IP and DHCP config from dnsmasq
    if [[ -f "$DNSMASQ_CONF" ]]; then
        # Extract IP from listen-address
        existing_ip=$(grep "^listen-address=" "$DNSMASQ_CONF" 2>/dev/null | cut -d= -f2 || echo "")
        # Extract DHCP range
        local dhcp_range
        dhcp_range=$(grep "^dhcp-range=" "$DNSMASQ_CONF" 2>/dev/null | cut -d= -f2 || echo "")
        if [[ -n "$dhcp_range" ]]; then
            existing_dhcp_start=$(echo "$dhcp_range" | cut -d, -f1)
            existing_dhcp_end=$(echo "$dhcp_range" | cut -d, -f2)
        fi
    fi

    # If we have actual values, use them and update config if needed
    if [[ "$has_actual_values" == "true" ]]; then
        local actual_interface="${actual_values[0]}"
        local actual_ssid="${actual_values[1]}"
        local actual_channel="${actual_values[2]}"
        local actual_ip="${actual_values[3]}"

        local config_needs_update=false

        # Compare actual vs config values (silently fix mismatches)
        if [[ -n "$actual_interface" ]] && [[ "$actual_interface" != "$existing_interface" ]]; then
            log_debug "Fixing config interface: '${existing_interface}' -> '${actual_interface}'"
            existing_interface="$actual_interface"
            config_needs_update=true
        fi

        if [[ -n "$actual_ssid" ]] && [[ "$actual_ssid" != "$existing_ssid" ]]; then
            log_debug "Fixing config SSID: '${existing_ssid}' -> '${actual_ssid}'"
            existing_ssid="$actual_ssid"
            config_needs_update=true
        fi

        if [[ -n "$actual_channel" ]] && [[ "$actual_channel" != "$existing_channel" ]]; then
            log_debug "Fixing config channel: '${existing_channel}' -> '${actual_channel}'"
            existing_channel="$actual_channel"
            config_needs_update=true
        fi

        if [[ -n "$actual_ip" ]] && [[ "$actual_ip" != "$existing_ip" ]]; then
            log_debug "Fixing config IP: '${existing_ip}' -> '${actual_ip}'"
            existing_ip="$actual_ip"
            config_needs_update=true
        fi

        # Update config files if there are discrepancies
        if [[ "$config_needs_update" == "true" ]]; then
            log_info "Updating config files to match running system..."

            # Get password from existing config (can't retrieve from running system)
            local existing_password
            existing_password=$(grep "^wpa_passphrase=" "$HOSTAPD_CONF" 2>/dev/null | cut -d= -f2 || echo "$DEFAULT_PASSWORD")

            # Update hostapd config
            if [[ -n "$actual_interface" ]] && [[ -n "$actual_ssid" ]] && [[ -n "$actual_channel" ]]; then
                configure_hostapd "$actual_interface" "$actual_ssid" "$existing_password" "$actual_channel" 2>/dev/null || true
            fi

            # Update dnsmasq config
            if [[ -n "$actual_interface" ]] && [[ -n "$actual_ip" ]]; then
                # Keep existing DHCP range if valid, otherwise use defaults
                if [[ -z "$existing_dhcp_start" ]] || ! validate_ipv4 "$existing_dhcp_start" 2>/dev/null; then
                    existing_dhcp_start="$DEFAULT_DHCP_START"
                fi
                if [[ -z "$existing_dhcp_end" ]] || ! validate_ipv4 "$existing_dhcp_end" 2>/dev/null; then
                    existing_dhcp_end="$DEFAULT_DHCP_END"
                fi
                configure_dnsmasq "$actual_interface" "$actual_ip" "$existing_dhcp_start" "$existing_dhcp_end" 2>/dev/null || true
            fi

            log_success "Config files updated"
        fi
    fi

    # Silently validate and fix config values (only if we don't have actual values)
    if [[ "$has_actual_values" == "false" ]]; then
        # Validate interface: should not contain spaces or brackets
        if [[ -n "$existing_interface" ]] && [[ "$existing_interface" =~ [[:space:]\[\]] ]]; then
            log_debug "Invalid interface in config, clearing: ${existing_interface}"
            existing_interface=""
        fi

        # Validate SSID: should not be empty, same as interface, or look like an interface name
        if [[ -n "$existing_ssid" ]]; then
            # Check if SSID matches common interface name patterns
            if [[ "$existing_ssid" =~ ^(wlan|eth|wlp|enp|eno|ens|wlo)[0-9]+$ ]] || \
               [[ "$existing_ssid" == "$existing_interface" ]]; then
                log_debug "Invalid SSID in config (looks like interface name), clearing: ${existing_ssid}"
                existing_ssid=""
            fi
        fi

        # Validate channel: should be a number between 1 and 14
        if [[ -n "$existing_channel" ]] && ! [[ "$existing_channel" =~ ^[0-9]+$ ]]; then
            log_debug "Invalid channel in config (not a number), clearing: ${existing_channel}"
            existing_channel=""
        elif [[ -n "$existing_channel" ]] && { [[ "$existing_channel" -lt 1 ]] || [[ "$existing_channel" -gt 14 ]]; }; then
            log_debug "Invalid channel in config (out of range), clearing: ${existing_channel}"
            existing_channel=""
        fi

        # Validate IP: should be a valid IPv4 address
        if [[ -n "$existing_ip" ]] && ! validate_ipv4 "$existing_ip" 2>/dev/null; then
            log_debug "Invalid IP in config, clearing: ${existing_ip}"
            existing_ip=""
        fi

        # Validate DHCP range: should be valid IPs
        if [[ -n "$existing_dhcp_start" ]] && ! validate_ipv4 "$existing_dhcp_start" 2>/dev/null; then
            log_debug "Invalid DHCP start in config, clearing: ${existing_dhcp_start}"
            existing_dhcp_start=""
        fi
        if [[ -n "$existing_dhcp_end" ]] && ! validate_ipv4 "$existing_dhcp_end" 2>/dev/null; then
            log_debug "Invalid DHCP end in config, clearing: ${existing_dhcp_end}"
            existing_dhcp_end=""
        fi
    fi

    if [[ -n "$existing_ssid" ]] && [[ -n "$existing_interface" ]]; then
        has_existing_config=true
        log_info "Found existing hotspot configuration:"
        log_info "  SSID: ${existing_ssid}"
        log_info "  Interface: ${existing_interface}"
        log_info "  IP Address: ${existing_ip:-$DEFAULT_IP}"
        log_info "  DHCP Range: ${existing_dhcp_start:-$DEFAULT_DHCP_START} - ${existing_dhcp_end:-$DEFAULT_DHCP_END}"
        log_info "  Channel: ${existing_channel:-$DEFAULT_CHANNEL}"

        # Check if hotspot is currently running
        local status_color status_text
        if systemctl is-active --quiet hostapd; then
            status_color="${GREEN}"
            status_text="Running"
        else
            status_color="${YELLOW}"
            status_text="Stopped"
        fi
        # Use echo -e to interpret color codes
        echo -e "$(date '+%Y-%m-%dT%H:%M:%SZ') INFO   Status: ${status_color}${status_text}${NC}"
    fi

    if [[ "$NON_INTERACTIVE" == "true" ]]; then
        # Use existing config if available, otherwise use defaults
        if [[ "$has_existing_config" == "true" ]]; then
            config=(
                "$existing_interface"
                "$existing_ssid"
                "$DEFAULT_PASSWORD"  # Can't retrieve password from config
                "${existing_ip:-$DEFAULT_IP}"
                "${existing_dhcp_start:-$DEFAULT_DHCP_START}"
                "${existing_dhcp_end:-$DEFAULT_DHCP_END}"
                "${existing_channel:-$DEFAULT_CHANNEL}"
            )
        else
            config=(
                "$DEFAULT_INTERFACE"
                "$DEFAULT_SSID"
                "$DEFAULT_PASSWORD"
                "$DEFAULT_IP"
                "$DEFAULT_DHCP_START"
                "$DEFAULT_DHCP_END"
                "$DEFAULT_CHANNEL"
            )
        fi
    else
        # Get WiFi interface
        local interfaces
        interfaces=$(get_wifi_interfaces)
        local interfaces_array=()
        
        while IFS= read -r line; do
            [[ -n "$line" ]] && interfaces_array+=("$line")
        done <<< "$interfaces"
        
        if [[ ${#interfaces_array[@]} -eq 0 ]]; then
            error_exit "No WiFi interfaces found that support AP mode"
        fi
        
        local selected_interface
        # Use existing interface if available and valid
        local interface_list=" ${interfaces_array[*]} "
        if [[ -n "$existing_interface" ]] && [[ "${interface_list}" =~ \ ${existing_interface}\  ]]; then
            selected_interface="$existing_interface"
            log_info "Using existing WiFi interface: $selected_interface"
        elif [[ ${#interfaces_array[@]} -eq 1 ]]; then
            selected_interface="${interfaces_array[0]}"
            log_info "Using WiFi interface: $selected_interface"
        else
            if [[ "$HAS_GUM_UTILS" == "true" ]]; then
                selected_interface=$(enhanced_choose "Select WiFi interface for hotspot:" "${interfaces_array[@]}")
            else
                echo "Available WiFi interfaces:"
                for i in "${!interfaces_array[@]}"; do
                    echo "  $((i+1)). ${interfaces_array[i]}"
                done
                echo -n "Select interface (1-${#interfaces_array[@]}): "
                read -r choice
                if [[ "$choice" =~ ^[0-9]+$ ]] && [[ $choice -ge 1 ]] && [[ $choice -le ${#interfaces_array[@]} ]]; then
                    selected_interface="${interfaces_array[$((choice-1))]}"
                else
                    error_exit "Invalid selection"
                fi
            fi
        fi
        
        # Get other configuration
        local ssid password ip_address dhcp_start dhcp_end channel

        # Use existing config as defaults if available
        local default_ssid="${existing_ssid:-$DEFAULT_SSID}"
        local default_channel="${existing_channel:-$DEFAULT_CHANNEL}"
        local default_ip="${existing_ip:-$DEFAULT_IP}"

        if [[ "$HAS_GUM_UTILS" == "true" ]]; then
            ssid=$(enhanced_input "Enter hotspot SSID:" "$default_ssid")
            password=$(enhanced_password "Enter hotspot password (min 8 chars):")
            ip_address=$(enhanced_input "Enter hotspot IP address:" "$default_ip")
            dhcp_start=$(enhanced_input "Enter DHCP range start:" "$DEFAULT_DHCP_START")
            dhcp_end=$(enhanced_input "Enter DHCP range end:" "$DEFAULT_DHCP_END")
            channel=$(enhanced_input "Enter WiFi channel (1-11):" "$default_channel")
        else
            echo -n "Enter hotspot SSID [$default_ssid]: "
            read -r ssid
            [[ -z "$ssid" ]] && ssid="$default_ssid"

            echo -n "Enter hotspot password (min 8 chars): "
            read -rs password
            echo
            [[ -z "$password" ]] && password="$DEFAULT_PASSWORD"

            echo -n "Enter hotspot IP address [$default_ip]: "
            read -r ip_address
            [[ -z "$ip_address" ]] && ip_address="$default_ip"

            echo -n "Enter DHCP range start [$DEFAULT_DHCP_START]: "
            read -r dhcp_start
            [[ -z "$dhcp_start" ]] && dhcp_start="$DEFAULT_DHCP_START"

            echo -n "Enter DHCP range end [$DEFAULT_DHCP_END]: "
            read -r dhcp_end
            [[ -z "$dhcp_end" ]] && dhcp_end="$DEFAULT_DHCP_END"

            echo -n "Enter WiFi channel (1-11) [$default_channel]: "
            read -r channel
            [[ -z "$channel" ]] && channel="$default_channel"
        fi
        
        # Validate password length
        if [[ ${#password} -lt 8 ]]; then
            error_exit "Password must be at least 8 characters long"
        fi
        
        config=(
            "$selected_interface"
            "$ssid"
            "$password"
            "$ip_address"
            "$dhcp_start"
            "$dhcp_end"
            "$channel"
        )
    fi
    
    printf '%s\n' "${config[@]}"
}

#######################################
# Configure systemd-resolved to avoid port 53 conflicts with dnsmasq
# Globals:
#   SYSTEMD_RESOLVED_CONF
# Arguments:
#   None
# Returns:
#   0 on success
#######################################
configure_systemd_resolved() {
    log_info "Configuring systemd-resolved to avoid port conflicts..."
    
    # Backup original configuration
    if [[ -f "$SYSTEMD_RESOLVED_CONF" ]] && [[ ! -f "${SYSTEMD_RESOLVED_CONF}.backup" ]]; then
        cp "$SYSTEMD_RESOLVED_CONF" "${SYSTEMD_RESOLVED_CONF}.backup"
        log_debug "Backed up systemd-resolved configuration"
    fi
    
    # Configure systemd-resolved
    cat > "$SYSTEMD_RESOLVED_CONF" << EOF
# DangerPrep WiFi Hotspot Configuration
# Modified to avoid port 53 conflicts with dnsmasq

[Resolve]
DNS=8.8.8.8 1.1.1.1
#FallbackDNS=
#Domains=
#LLMNR=yes
#MulticastDNS=yes
#DNSSEC=yes
#DNSOverTLS=no
#Cache=yes
#CacheFromLocalhost=no
DNSStubListener=no
#DNSStubListenerExtra=
#ReadEtcHosts=yes
#ResolveUnicastSingleLabel=no
EOF
    
    # Restart systemd-resolved
    systemctl restart systemd-resolved
    log_info "systemd-resolved configured and restarted"
}

#######################################
# Configure hostapd for WiFi access point
# Globals:
#   HOSTAPD_CONF, SCRIPT_NAME, SCRIPT_VERSION
# Arguments:
#   $1 - WiFi interface name
#   $2 - SSID for the hotspot
#   $3 - WPA2 password (min 8 characters)
#   $4 - WiFi channel number
# Returns:
#   0 on success
#######################################
configure_hostapd() {
    local interface="$1"
    local ssid="$2"
    local password="$3"
    local channel="$4"

    # Validate inputs
    if ! validate_interface "${interface}"; then
        log_error "Invalid interface name: ${interface}"
        return 1
    fi

    if ! validate_ssid "${ssid}"; then
        log_error "Invalid SSID: ${ssid}"
        return 1
    fi

    if ! validate_wifi_password "${password}"; then
        log_error "Invalid password (must be 8-63 characters)"
        return 1
    fi

    if ! validate_wifi_channel "${channel}"; then
        log_error "Invalid channel: ${channel}"
        return 1
    fi

    log_info "Configuring hostapd..."

    # Create hostapd configuration directory
    mkdir -p "$(dirname "${HOSTAPD_CONF}")"

    # Backup original configuration if it exists
    if [[ -f "${HOSTAPD_CONF}" ]] && [[ ! -f "${HOSTAPD_CONF}.backup" ]]; then
        cp "${HOSTAPD_CONF}" "${HOSTAPD_CONF}.backup"
        log_debug "Backed up hostapd configuration"
    fi

    # Detect country code from system locale
    local country_code
    country_code=$(detect_country_code)
    log_debug "Using country code: ${country_code}"

    # Create hostapd configuration
    cat > "${HOSTAPD_CONF}" << EOF
# DangerPrep WiFi Hotspot Configuration
# Generated by ${SCRIPT_NAME} v${SCRIPT_VERSION}

# Interface configuration
interface=${interface}
driver=nl80211

# Network configuration
ssid=${ssid}
hw_mode=g
channel=${channel}
wmm_enabled=0
macaddr_acl=0
auth_algs=1
ignore_broadcast_ssid=0

# Security configuration
wpa=2
wpa_passphrase=${password}
wpa_key_mgmt=WPA-PSK
wpa_pairwise=TKIP
rsn_pairwise=CCMP

# Additional settings for better compatibility
ieee80211n=1
ht_capab=[HT40][SHORT-GI-20][DSSS_CCK-40]
country_code=${country_code}
EOF

    # Set secure permissions (only root can read the password)
    chmod 600 "${HOSTAPD_CONF}"
    log_debug "Set secure permissions on ${HOSTAPD_CONF}"

    log_info "hostapd configuration created"
}

#######################################
# Configure dnsmasq for DHCP and DNS
# Globals:
#   DNSMASQ_CONF, SCRIPT_NAME, SCRIPT_VERSION
# Arguments:
#   $1 - Interface name
#   $2 - IP address
#   $3 - DHCP range start
#   $4 - DHCP range end
# Returns:
#   0 on success
#######################################
configure_dnsmasq() {
    local interface="$1"
    local ip_address="$2"
    local dhcp_start="$3"
    local dhcp_end="$4"

    # Validate inputs
    if ! validate_interface "${interface}"; then
        log_error "Invalid interface name: ${interface}"
        return 1
    fi

    if ! validate_ipv4 "${ip_address}"; then
        log_error "Invalid IP address: ${ip_address}"
        return 1
    fi

    if ! validate_dhcp_range "${dhcp_start}" "${dhcp_end}" "${ip_address}"; then
        log_error "Invalid DHCP range: ${dhcp_start} - ${dhcp_end}"
        return 1
    fi

    log_info "Configuring dnsmasq..."

    # Create dnsmasq configuration directory
    mkdir -p "$(dirname "${DNSMASQ_CONF}")"

    # Create dnsmasq configuration for hotspot
    cat > "${DNSMASQ_CONF}" << EOF
# DangerPrep WiFi Hotspot DHCP and DNS Configuration
# Generated by ${SCRIPT_NAME} v${SCRIPT_VERSION}

# Interface configuration
interface=${interface}
bind-interfaces
listen-address=${ip_address}

# DHCP configuration
dhcp-range=${dhcp_start},${dhcp_end},255.255.255.0,24h
dhcp-option=3,${ip_address}
dhcp-option=6,${ip_address}

# DHCP Option 114 - Captive Portal URI (RFC 8910)
# Points devices to the captive portal for automatic detection
dhcp-option=114,"https://portal.danger.diy"

# DNS configuration
server=8.8.8.8
server=1.1.1.1
domain-needed
bogus-priv
no-resolv

# Captive Portal Detection - DNS Interception
# Intercept common captive portal detection URLs and redirect to gateway
# This triggers the captive portal popup on iOS, Android, Windows, macOS
address=/captive.apple.com/${ip_address}
address=/connectivitycheck.gstatic.com/${ip_address}
address=/connectivitycheck.android.com/${ip_address}
address=/clients3.google.com/${ip_address}
address=/www.msftconnecttest.com/${ip_address}
address=/www.msftncsi.com/${ip_address}
address=/detectportal.firefox.com/${ip_address}

# Additional settings
expand-hosts
cache-size=1000
local-ttl=300

# Log queries for debugging (comment out for production)
# log-queries
# log-dhcp
EOF

    log_success "dnsmasq configuration created"
}

#######################################
# Configure IP forwarding
# Uses enable_ip_forwarding from firewall-utils
# Globals:
#   SYSCTL_CONF, SCRIPT_NAME, SCRIPT_VERSION
# Returns:
#   0 on success
#######################################
configure_ip_forwarding() {
    log_info "Configuring IP forwarding..."

    # Use firewall-utils function with persistent config
    if enable_ip_forwarding "${SYSCTL_CONF}"; then
        log_success "IP forwarding enabled"
        return 0
    else
        log_error "Failed to enable IP forwarding"
        return 1
    fi
}

#######################################
# Configure firewall rules for hotspot NAT and forwarding
# Uses safe firewall utilities that don't destroy existing rules
# Globals:
#   IPTABLES_BACKUP
# Arguments:
#   $1 - Hotspot WiFi interface name
#   $2 - Hotspot IP address
# Returns:
#   0 on success
#######################################
configure_firewall() {
    local interface="$1"
    local ip_address="$2"

    log_info "Configuring firewall rules..."

    # Backup existing iptables rules before making changes
    if backup_iptables_rules "${IPTABLES_BACKUP}"; then
        log_debug "Backed up existing iptables rules to ${IPTABLES_BACKUP}"
    else
        log_warn "Could not backup iptables rules"
    fi

    # Get the default route interface (usually for internet connection)
    local wan_interface
    wan_interface=$(get_wan_interface)

    if [[ -z "${wan_interface}" ]]; then
        log_warn "No default route found. NAT rules may not work properly."
        log_warn "Hotspot will be created but internet sharing may not work."
        wan_interface="eth0"  # Fallback
    else
        log_debug "Using WAN interface: ${wan_interface}"

        # Check if WAN has internet connectivity
        if check_internet_connectivity "${wan_interface}"; then
            log_debug "WAN interface has internet connectivity"
        else
            log_warn "WAN interface may not have internet connectivity"
        fi
    fi

    # Use safe firewall configuration from firewall-utils
    # This creates custom chains and doesn't destroy existing rules
    if configure_hotspot_firewall "${interface}" "${wan_interface}" "${ip_address}"; then
        log_success "Firewall rules configured successfully"
        return 0
    else
        log_error "Failed to configure firewall rules"
        return 1
    fi
}

#######################################
# Configure network interface for hotspot
# Arguments:
#   $1 - Interface name
#   $2 - IP address
# Returns:
#   0 on success
#######################################
configure_interface() {
    local interface="$1"
    local ip_address="$2"

    # Validate inputs
    if ! validate_interface "${interface}"; then
        log_error "Invalid interface name: ${interface}"
        return 1
    fi

    if ! validate_ipv4 "${ip_address}"; then
        log_error "Invalid IP address: ${ip_address}"
        return 1
    fi

    log_info "Configuring network interface ${interface}..."

    # Bring interface down
    ip link set "${interface}" down 2>/dev/null || true

    # Set interface IP address
    ip addr flush dev "${interface}" 2>/dev/null || true
    ip addr add "${ip_address}/24" dev "${interface}"

    # Bring interface up
    ip link set "${interface}" up

    # Disable power management to prevent AP instability
    disable_power_management "${interface}"
    log_debug "Disabled power management on ${interface}"

    log_success "Interface ${interface} configured with IP ${ip_address}"
}

# Start services
start_services() {
    log_info "Starting hotspot services..."

    # Stop services first to ensure clean start
    systemctl stop hostapd 2>/dev/null || true
    systemctl stop dnsmasq 2>/dev/null || true

    # Start and enable services
    systemctl enable hostapd
    systemctl enable dnsmasq

    systemctl start hostapd
    systemctl start dnsmasq

    # Wait a moment and check status
    sleep 2

    if systemctl is-active --quiet hostapd && systemctl is-active --quiet dnsmasq; then
        log_info "✓ Hotspot services started successfully"
        return 0
    else
        log_error "✗ Failed to start hotspot services"
        return 1
    fi
}

# Show hotspot status
show_status() {
    echo "DangerPrep WiFi Hotspot Status"
    echo "=============================="
    echo

    # Check service status
    echo "Service Status:"
    if systemctl is-active --quiet hostapd; then
        echo -e "  hostapd: ${GREEN}Running${NC}"
    else
        echo -e "  hostapd: ${RED}Stopped${NC}"
    fi

    if systemctl is-active --quiet dnsmasq; then
        echo -e "  dnsmasq: ${GREEN}Running${NC}"
    else
        echo -e "  dnsmasq: ${RED}Stopped${NC}"
    fi

    echo

    # Show configuration - prefer actual values from running system
    if [[ -f "$HOSTAPD_CONF" ]]; then
        echo "Hotspot Configuration:"

        local ssid interface channel country_code ip_addr

        # Try to get actual values from running system first
        if systemctl is-active --quiet hostapd; then
            local actual_values=()
            while IFS= read -r line; do
                actual_values+=("$line")
            done < <(get_actual_hotspot_values)

            if [[ ${#actual_values[@]} -eq 4 ]]; then
                interface="${actual_values[0]}"
                ssid="${actual_values[1]}"
                channel="${actual_values[2]}"
                ip_addr="${actual_values[3]}"
            fi
        fi

        # Fall back to config values if actual values not available
        if [[ -z "$interface" ]]; then
            interface=$(grep "^interface=" "$HOSTAPD_CONF" 2>/dev/null | cut -d= -f2 || echo "Unknown")
        fi
        if [[ -z "$ssid" ]]; then
            ssid=$(grep "^ssid=" "$HOSTAPD_CONF" 2>/dev/null | cut -d= -f2 || echo "Unknown")
        fi
        if [[ -z "$channel" ]]; then
            channel=$(grep "^channel=" "$HOSTAPD_CONF" 2>/dev/null | cut -d= -f2 || echo "Unknown")
        fi
        country_code=$(grep "^country_code=" "$HOSTAPD_CONF" 2>/dev/null | cut -d= -f2 || echo "Unknown")

        echo "  SSID: ${ssid}"
        echo "  Interface: ${interface}"
        echo "  Channel: ${channel}"
        echo "  Country Code: ${country_code}"

        # Show IP and DHCP range
        if [[ -z "$ip_addr" ]] && [[ -f "$DNSMASQ_CONF" ]]; then
            ip_addr=$(grep "^listen-address=" "$DNSMASQ_CONF" 2>/dev/null | cut -d= -f2 || echo "")
        fi

        # If still no IP, try to get from interface
        if [[ -z "$ip_addr" ]] && [[ "$interface" != "Unknown" ]]; then
            ip_addr=$(ip addr show "$interface" 2>/dev/null | grep "inet " | awk '{print $2}' | cut -d/ -f1 || echo "Unknown")
        fi

        echo "  IP Address: ${ip_addr:-Unknown}"

        # Show DHCP range from dnsmasq config
        if [[ -f "$DNSMASQ_CONF" ]]; then
            local dhcp_range
            dhcp_range=$(grep "^dhcp-range=" "$DNSMASQ_CONF" 2>/dev/null | cut -d= -f2 || echo "")

            if [[ -n "$dhcp_range" ]]; then
                local dhcp_start dhcp_end
                dhcp_start=$(echo "$dhcp_range" | cut -d, -f1)
                dhcp_end=$(echo "$dhcp_range" | cut -d, -f2)

                # Validate DHCP range
                if validate_ipv4 "$dhcp_start" 2>/dev/null && validate_ipv4 "$dhcp_end" 2>/dev/null; then
                    echo "  DHCP Range: ${dhcp_start} - ${dhcp_end}"
                else
                    echo "  DHCP Range: Invalid (${dhcp_start} - ${dhcp_end})"
                fi
            else
                echo "  DHCP Range: Unknown"
            fi
        fi

        # Show interface status
        if [[ "$interface" != "Unknown" ]] && ip link show "$interface" &>/dev/null 2>&1; then
            echo -e "  Interface Status: ${GREEN}UP${NC}"
        else
            echo -e "  Interface Status: ${RED}DOWN${NC}"
        fi
    else
        echo "No hotspot configuration found"
    fi

    echo

    # Show firewall status
    if check_hotspot_firewall 2>/dev/null; then
        echo -e "Firewall Rules: ${GREEN}Active${NC}"
    else
        echo -e "Firewall Rules: ${RED}Not configured${NC}"
    fi

    # Show IP forwarding status
    local ip_forward
    ip_forward=$(cat /proc/sys/net/ipv4/ip_forward 2>/dev/null || echo "0")
    if [[ "$ip_forward" == "1" ]]; then
        echo -e "IP Forwarding: ${GREEN}Enabled${NC}"
    else
        echo -e "IP Forwarding: ${RED}Disabled${NC}"
    fi

    echo

    # Show connected clients if dnsmasq is running
    if systemctl is-active --quiet dnsmasq && [[ -f "/var/lib/misc/dnsmasq.leases" ]]; then
        local client_count
        client_count=$(wc -l < /var/lib/misc/dnsmasq.leases 2>/dev/null || echo "0")
        echo "Connected Clients: ${client_count}"

        if [[ "$client_count" -gt 0 ]]; then
            echo "Client Details:"
            while IFS= read -r line; do
                local mac ip hostname
                mac=$(echo "$line" | awk '{print $2}')
                ip=$(echo "$line" | awk '{print $3}')
                hostname=$(echo "$line" | awk '{print $4}')
                echo "  - ${ip} (${mac}) ${hostname}"
            done < /var/lib/misc/dnsmasq.leases
        fi
    fi
}

#######################################
# Disable hotspot and clean up configuration
# Uses safe firewall removal that doesn't affect other rules
# Globals:
#   HOSTAPD_CONF, DNSMASQ_CONF, SYSCTL_CONF, SYSTEMD_RESOLVED_CONF
#   IPTABLES_BACKUP
# Returns:
#   0 on success
#######################################
disable_hotspot() {
    log_info "Disabling WiFi hotspot..."

    # Stop services
    systemctl stop hostapd 2>/dev/null || true
    systemctl stop dnsmasq 2>/dev/null || true
    systemctl disable hostapd 2>/dev/null || true
    systemctl disable dnsmasq 2>/dev/null || true

    # Remove configuration files
    [[ -f "${HOSTAPD_CONF}" ]] && rm -f "${HOSTAPD_CONF}"
    [[ -f "${DNSMASQ_CONF}" ]] && rm -f "${DNSMASQ_CONF}"

    # Restore systemd-resolved configuration
    if [[ -f "${SYSTEMD_RESOLVED_CONF}.backup" ]]; then
        mv "${SYSTEMD_RESOLVED_CONF}.backup" "${SYSTEMD_RESOLVED_CONF}"
        systemctl restart systemd-resolved 2>/dev/null || true
        log_info "systemd-resolved configuration restored"
    fi

    # Remove only our firewall rules using safe removal
    if remove_hotspot_firewall; then
        log_debug "Removed hotspot firewall rules"
    else
        log_warn "Could not remove hotspot firewall rules"
    fi

    # Optionally restore original iptables rules
    if [[ -f "${IPTABLES_BACKUP}" ]]; then
        if restore_iptables_rules "${IPTABLES_BACKUP}"; then
            log_info "Restored original iptables rules"
            rm -f "${IPTABLES_BACKUP}"
        else
            log_warn "Could not restore original iptables rules"
        fi
    fi

    # Disable IP forwarding using safe function
    disable_ip_forwarding "${SYSCTL_CONF}"
    log_debug "Disabled IP forwarding"

    log_success "WiFi hotspot disabled and configuration removed"
}

# Main execution function
main() {
    # Parse command line arguments
    while [[ $# -gt 0 ]]; do
        case $1 in
            -h|--help)
                show_help
                exit 0
                ;;
            -v|--verbose)
                VERBOSE=true
                shift
                ;;
            -d|--disable)
                DISABLE_HOTSPOT=true
                shift
                ;;
            -s|--status)
                SHOW_STATUS=true
                shift
                ;;
            --non-interactive)
                NON_INTERACTIVE=true
                shift
                ;;
            *)
                error_exit "Unknown option: $1. Use --help for usage information."
                ;;
        esac
    done

    # Setup logging after parsing arguments (fixes verbose flag timing)
    setup_logging

    # Check root privileges
    check_root

    # Show banner if available
    if [[ "$HAS_BANNER" == "true" ]]; then
        show_banner_with_title "WiFi Hotspot Setup" "network"
    else
        echo "DangerPrep WiFi Hotspot Setup v${SCRIPT_VERSION}"
        echo "=============================================="
    fi

    # Handle status request
    if [[ "$SHOW_STATUS" == "true" ]]; then
        show_status
        exit 0
    fi

    # Handle disable request
    if [[ "$DISABLE_HOTSPOT" == "true" ]]; then
        create_lock
        disable_hotspot
        exit 0
    fi

    # Check dependencies
    check_dependencies

    # Create lock file
    create_lock

    # Get hotspot configuration
    local config
    config=$(get_hotspot_config)
    local config_array=()

    while IFS= read -r line; do
        config_array+=("$line")
    done <<< "$config"

    local interface="${config_array[0]}"
    local ssid="${config_array[1]}"
    local password="${config_array[2]}"
    local ip_address="${config_array[3]}"
    local dhcp_start="${config_array[4]}"
    local dhcp_end="${config_array[5]}"
    local channel="${config_array[6]}"

    # Final validation of all configuration values
    log_debug "Validating configuration..."

    if ! validate_interface "${interface}"; then
        error_exit "Invalid interface name: ${interface}"
    fi

    if ! validate_ssid "${ssid}"; then
        error_exit "Invalid SSID: ${ssid}"
    fi

    if ! validate_wifi_password "${password}"; then
        error_exit "Invalid password (must be 8-63 characters)"
    fi

    if ! validate_ipv4 "${ip_address}"; then
        error_exit "Invalid IP address: ${ip_address}"
    fi

    if ! validate_dhcp_range "${dhcp_start}" "${dhcp_end}" "${ip_address}"; then
        error_exit "Invalid DHCP range: ${dhcp_start} - ${dhcp_end}"
    fi

    if ! validate_wifi_channel "${channel}"; then
        error_exit "Invalid WiFi channel: ${channel}"
    fi

    log_info "Setting up WiFi hotspot with the following configuration:"
    log_info "  Interface: ${interface}"
    log_info "  SSID: ${ssid}"
    log_info "  IP Address: ${ip_address}"
    log_info "  DHCP Range: ${dhcp_start} - ${dhcp_end}"
    log_info "  Channel: ${channel}"

    # Configure system components
    configure_systemd_resolved
    configure_hostapd "$interface" "$ssid" "$password" "$channel"
    configure_dnsmasq "$interface" "$ip_address" "$dhcp_start" "$dhcp_end"
    configure_ip_forwarding
    configure_interface "$interface" "$ip_address"
    configure_firewall "$interface" "$ip_address"

    # Start services
    if start_services; then
        echo
        log_info "✓ WiFi hotspot setup completed successfully!"
        log_info "  SSID: $ssid"
        log_info "  Password: $password"
        log_info "  IP Address: $ip_address"
        echo
        log_info "Use '$SCRIPT_NAME --status' to check hotspot status"
        log_info "Use '$SCRIPT_NAME --disable' to remove hotspot configuration"
    else
        error_exit "Failed to start hotspot services. Check logs for details."
    fi
}

# Run main function if script is executed directly
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    main "$@"
fi
