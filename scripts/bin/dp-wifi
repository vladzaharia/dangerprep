#!/bin/bash
# DangerPrep WiFi Connection Manager
# Changes WiFi connection to a new SSID with interactive prompts
# 
# Usage:
#   dp-wifi [OPTIONS]
#
# Options:
#   -h, --help       Show this help message
#   -v, --verbose    Enable verbose output
#   -i, --interface  Specify WiFi interface (optional)
#   -s, --ssid       Specify SSID (optional, will prompt if not provided)
#   -p, --password   Specify password (optional, will prompt if not provided)
#   --non-interactive  Run without prompts (requires --interface, --ssid, --password)
#
# Dependencies:
#   - nmcli (NetworkManager command line interface)
#   - gum (for enhanced UI, optional)

set -euo pipefail

# Script configuration
readonly SCRIPT_NAME="dp-wifi"
readonly SCRIPT_VERSION="1.0.0"
readonly LOCK_FILE_DEFAULT="/var/run/dp-wifi.lock"

# Log file (not readonly so it can be exported)
LOG_FILE="/var/log/dp-wifi.log"

# Lock file descriptor (will be set by acquire_lock)
LOCK_FD=""

# Default options
VERBOSE=false
NON_INTERACTIVE=false
SHOW_STATUS=false
INTERFACE=""
SSID=""
PASSWORD=""

# Colors for output
readonly RED='\033[0;31m'
readonly GREEN='\033[0;32m'
readonly YELLOW='\033[1;33m'
readonly NC='\033[0m' # No Color

# Source shared utilities if available
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
SHARED_DIR="${SCRIPT_DIR}/../shared"

# Source shared utilities
HAS_GUM_UTILS=false
HAS_BANNER=false

if [[ -f "${SHARED_DIR}/gum-utils.sh" ]]; then
    # shellcheck source=scripts/shared/gum-utils.sh
    source "${SHARED_DIR}/gum-utils.sh"
    HAS_GUM_UTILS=true
fi

if [[ -f "${SHARED_DIR}/banner.sh" ]]; then
    # shellcheck source=scripts/shared/banner.sh
    source "${SHARED_DIR}/banner.sh"
    HAS_BANNER=true
fi

# Source validation utilities
if [[ -f "${SHARED_DIR}/validation-utils.sh" ]]; then
    # shellcheck source=scripts/shared/validation-utils.sh
    source "${SHARED_DIR}/validation-utils.sh"
fi

# Source network utilities
if [[ -f "${SHARED_DIR}/network-utils.sh" ]]; then
    # shellcheck source=scripts/shared/network-utils.sh
    source "${SHARED_DIR}/network-utils.sh"
fi

# Source lock utilities
if [[ -f "${SHARED_DIR}/lock-utils.sh" ]]; then
    # shellcheck source=scripts/shared/lock-utils.sh
    source "${SHARED_DIR}/lock-utils.sh"
fi

#######################################
# Setup logging configuration
# Globals:
#   VERBOSE, LOG_FILE, DEBUG
# Arguments:
#   None
# Returns:
#   0 on success
#######################################
setup_logging() {
    # Set DEBUG environment variable for gum-utils debug logging
    [[ "${VERBOSE}" == "true" ]] && export DEBUG=true

    # Set LOG_FILE for gum-utils file logging
    export LOG_FILE="${LOG_FILE}"
}

#######################################
# Error handler that logs error and exits
# Globals:
#   None
# Arguments:
#   Error message
# Returns:
#   Exits with status 1
#######################################
error_exit() {
    log_error "$@"
    cleanup
    exit 1
}

#######################################
# Cleanup function to release resources
# Globals:
#   LOCK_FD
# Arguments:
#   None
# Returns:
#   0 on success
#######################################
cleanup() {
    if [[ -n "${LOCK_FD}" ]]; then
        release_lock "${LOCK_FD}"
    fi
}

#######################################
# Handle interrupt signal (Ctrl-C)
# Globals:
#   None
# Arguments:
#   None
# Returns:
#   Exits with status 130
#######################################
handle_interrupt() {
    echo
    log_info "Received interrupt signal. Exiting..."
    cleanup
    exit 130
}

# Trap cleanup on exit and interrupt
trap cleanup EXIT
trap handle_interrupt INT

#######################################
# Display help message
# Globals:
#   SCRIPT_VERSION, SCRIPT_NAME, LOG_FILE
# Arguments:
#   None
# Outputs:
#   Writes help text to stdout
# Returns:
#   0 on success
#######################################
show_help() {
    cat << EOF
DangerPrep WiFi Connection Manager v${SCRIPT_VERSION}

DESCRIPTION:
    Interactive tool to change WiFi connection to a new SSID. Automatically
    detects available WiFi interfaces and networks, then connects to the
    specified network with the provided credentials.

USAGE:
    ${SCRIPT_NAME} [OPTIONS]

OPTIONS:
    -h, --help           Show this help message and exit
    -v, --verbose        Enable verbose output and debugging
    -i, --interface      Specify WiFi interface (e.g., wlan0, wlp2s0)
    -s, --ssid           Specify SSID to connect to
    -p, --password       Specify WiFi password
    --status             Show current WiFi connection status
    --non-interactive    Run without prompts (requires all parameters)

EXAMPLES:
    ${SCRIPT_NAME}                                    # Interactive mode
    ${SCRIPT_NAME} --interface wlan0                 # Pre-select interface
    ${SCRIPT_NAME} --ssid "MyNetwork" --password "pass123"  # Pre-fill credentials
    ${SCRIPT_NAME} --status                          # Show current WiFi status
    ${SCRIPT_NAME} --non-interactive -i wlan0 -s "MyNetwork" -p "pass123"  # Fully automated

DEPENDENCIES:
    - nmcli (NetworkManager command line interface)
    - gum (for enhanced UI, optional)

LOGS:
    Operations are logged to: ${LOG_FILE}

EOF
}

#######################################
# Check for required system dependencies
# Globals:
#   None
# Arguments:
#   None
# Returns:
#   Exits with error if dependencies are missing and cannot be installed
#######################################
check_dependencies() {
    local deps=("nmcli")
    local missing_deps=()
    
    for dep in "${deps[@]}"; do
        if ! command -v "$dep" >/dev/null 2>&1; then
            missing_deps+=("$dep")
        fi
    done
    
    if [[ ${#missing_deps[@]} -gt 0 ]]; then
        log_warn "Missing dependencies: ${missing_deps[*]}"
        log_info "Installing missing packages..."
        
        # Install missing packages
        if command -v apt-get >/dev/null 2>&1; then
            apt-get update
            for dep in "${missing_deps[@]}"; do
                case "$dep" in
                    "nmcli")
                        apt-get install -y network-manager
                        ;;
                    *)
                        apt-get install -y "$dep"
                        ;;
                esac
            done
        else
            error_exit "Package manager not found. Please install: ${missing_deps[*]}"
        fi
    fi
    
    # Check if NetworkManager is running
    if ! systemctl is-active --quiet NetworkManager; then
        log_warn "NetworkManager is not running. Starting it..."
        systemctl start NetworkManager
    fi
    
    log_debug "All dependencies satisfied"
}

#######################################
# Create lock file using atomic locking
# Globals:
#   LOCK_FILE_DEFAULT, LOCK_FD
# Returns:
#   0 on success, exits on failure
#######################################
create_lock() {
    if ! acquire_lock "${LOCK_FILE_DEFAULT}" "LOCK_FD"; then
        error_exit "Failed to acquire lock. Another instance may be running."
    fi

    log_debug "Acquired lock (FD: ${LOCK_FD})"
}

#######################################
# Get available WiFi interfaces from NetworkManager
# Optimized to reduce subprocess calls
# Globals:
#   None
# Arguments:
#   None
# Outputs:
#   Writes list of WiFi interfaces to stdout, one per line
# Returns:
#   0 on success, 1 if no interfaces found
#######################################
get_wifi_interfaces() {
    local interfaces

    # Optimized: single awk command instead of grep+cut pipeline
    interfaces=$(nmcli -t -f DEVICE,TYPE device status | awk -F: '$2 == "wifi" {print $1}')

    if [[ -z "${interfaces}" ]]; then
        return 1
    fi

    echo "${interfaces}"
}

#######################################
# Get interface state from NetworkManager
# Helper function to reduce code duplication
# Globals:
#   None
# Arguments:
#   $1 - WiFi interface name
# Outputs:
#   Writes state to stdout (connected, disconnected, unavailable, etc.)
# Returns:
#   0 on success, 1 if interface not found
#######################################
get_interface_state() {
    local interface="${1}"
    local state

    state=$(nmcli -t -f DEVICE,STATE device status 2>/dev/null | awk -F: -v iface="${interface}" '$1 == iface {print $2; exit}')

    if [[ -z "${state}" ]]; then
        return 1
    fi

    echo "${state}"
}

#######################################
# Get current SSID for an interface
# Helper function to reduce code duplication
# Globals:
#   None
# Arguments:
#   $1 - WiFi interface name (optional, returns active SSID if omitted)
# Outputs:
#   Writes SSID to stdout
# Returns:
#   0 on success, 1 if not connected
#######################################
get_current_ssid() {
    local interface="${1:-}"
    local ssid

    if [[ -n "${interface}" ]]; then
        # Get SSID for specific interface
        ssid=$(nmcli -t -f DEVICE,CONNECTION device status 2>/dev/null | awk -F: -v iface="${interface}" '$1 == iface {print $2; exit}')
    else
        # Get currently active SSID
        ssid=$(nmcli -t -f active,ssid dev wifi 2>/dev/null | awk -F: '$1 == "yes" {print $2; exit}')
    fi

    if [[ -z "${ssid}" ]]; then
        return 1
    fi

    echo "${ssid}"
}

#######################################
# Scan for available WiFi networks on an interface
# Uses safe_wifi_scan from network-utils with timeout
# Globals:
#   None
# Arguments:
#   $1 - WiFi interface name
# Outputs:
#   Writes list of SSIDs to stdout, one per line
# Returns:
#   0 on success, 1 if no networks found
#######################################
scan_networks() {
    local interface="${1}"

    log_info "Scanning for available networks on ${interface}..."

    # Use safe scan with timeout from network-utils
    local networks
    if ! networks=$(safe_wifi_scan "${interface}" 30); then
        log_warn "No networks found on ${interface}"
        return 1
    fi

    # Validate networks found (count non-empty lines)
    if [[ -z "${networks}" ]] || ! echo "${networks}" | grep -q .; then
        log_warn "No networks found on ${interface}"
        return 1
    fi

    local network_count
    network_count=$(echo "${networks}" | grep -c .)
    log_info "Found ${network_count} networks"

    echo "${networks}"
}

#######################################
# Connect to a WiFi network using NetworkManager
# Uses safe_wifi_connect to avoid password exposure in process list
# Globals:
#   None
# Arguments:
#   $1 - WiFi interface name
#   $2 - SSID to connect to
#   $3 - WiFi password
# Returns:
#   0 on success, 1 on failure
#######################################
connect_wifi() {
    local interface="$1"
    local ssid="$2"
    local password="$3"

    # Validate inputs
    if ! validate_interface "${interface}"; then
        log_error "Invalid interface name: ${interface}"
        return 1
    fi

    if ! validate_ssid "${ssid}"; then
        log_error "Invalid SSID: ${ssid}"
        return 1
    fi

    if ! validate_wifi_password "${password}"; then
        log_error "Invalid password (must be 8-63 characters)"
        return 1
    fi

    log_info "Connecting to '${ssid}' on interface '${interface}'..."

    # Use safe connect from network-utils (avoids password in process list)
    if safe_wifi_connect "${interface}" "${ssid}" "${password}" 30; then
        log_success "Successfully connected to '${ssid}'"
        return 0
    else
        log_error "Failed to connect to '${ssid}'"
        return 1
    fi
}

#######################################
# Verify WiFi connection
# Uses verify_wifi_connection from network-utils
# Arguments:
#   $1 - Interface name
#   $2 - Expected SSID
# Returns:
#   0 on success, 1 on failure
#######################################
verify_connection() {
    local interface="$1"
    local expected_ssid="$2"

    log_info "Verifying connection..."

    # Use network-utils verification with timeout
    if verify_wifi_connection "${interface}" "${expected_ssid}" 10; then
        log_success "✓ Successfully connected to '${expected_ssid}'"

        # Get IP address
        local ip_address
        ip_address=$(nmcli -t -f IP4.ADDRESS dev show "${interface}" 2>/dev/null | cut -d: -f2 | cut -d/ -f1)
        [[ -n "${ip_address}" ]] && log_info "IP Address: ${ip_address}"

        return 0
    else
        log_error "✗ Connection verification failed"
        local current_ssid
        current_ssid=$(get_current_ssid "${interface}")
        [[ -n "${current_ssid}" ]] && log_error "Currently connected to: ${current_ssid}"
        return 1
    fi
}

#######################################
# Display comprehensive WiFi connection status
# Shows NetworkManager status, interface details, signal strength,
# connection info, and available networks
# Globals:
#   RED, GREEN, YELLOW, NC
# Arguments:
#   None
# Outputs:
#   Writes status information to stdout
# Returns:
#   0 on success, 1 if no interfaces found
#######################################
show_status() {
    echo "DangerPrep WiFi Connection Status"
    echo "================================="
    echo

    # Check NetworkManager status
    echo "Service Status:"
    if systemctl is-active --quiet NetworkManager; then
        echo -e "  NetworkManager: ${GREEN}Running${NC}"
    else
        echo -e "  NetworkManager: ${RED}Stopped${NC}"
        return 1
    fi

    echo

    # Get all WiFi interfaces using optimized function
    local interfaces_list interfaces_array=()
    if ! interfaces_list=$(get_wifi_interfaces); then
        echo "No WiFi interfaces found"
        return 1
    fi

    # Convert to array
    while IFS= read -r interface; do
        [[ -n "${interface}" ]] && interfaces_array+=("${interface}")
    done <<< "${interfaces_list}"

    # Show status for each WiFi interface
    for interface in "${interfaces_array[@]}"; do
        echo "Interface: ${interface}"

        # Get interface state using helper function
        local state
        if ! state=$(get_interface_state "${interface}"); then
            echo "  State: Unknown"
            continue
        fi

        # Color code the state
        case "$state" in
            "connected")
                echo -e "  State: ${GREEN}${state}${NC}"
                ;;
            "disconnected")
                echo -e "  State: ${YELLOW}${state}${NC}"
                ;;
            "unavailable")
                echo -e "  State: ${RED}${state}${NC}"
                ;;
            *)
                echo "  State: ${state}"
                ;;
        esac

        # Get current connection if connected
        if [[ "${state}" == "connected" ]]; then
            local current_ssid

            # Use optimized helper function
            if current_ssid=$(get_current_ssid "${interface}"); then
                echo "  Connected to: ${current_ssid}"
            fi

            # Get IP address and gateway
            local ip_address gateway dns
            ip_address=$(nmcli -t -f IP4.ADDRESS dev show "$interface" | cut -d: -f2 | cut -d/ -f1)
            gateway=$(nmcli -t -f IP4.GATEWAY dev show "$interface" | cut -d: -f2)
            dns=$(nmcli -t -f IP4.DNS dev show "$interface" | cut -d: -f2 | head -1)

            [[ -n "$ip_address" ]] && echo "  IP Address: ${ip_address}"
            [[ -n "$gateway" ]] && echo "  Gateway: ${gateway}"
            [[ -n "$dns" ]] && echo "  DNS: ${dns}"

            # Get signal strength and rate
            local signal rate
            signal=$(nmcli -t -f IN-USE,SIGNAL dev wifi | grep "^\*:" | cut -d: -f2)
            rate=$(nmcli -t -f IN-USE,RATE dev wifi | grep "^\*:" | cut -d: -f2)

            if [[ -n "$signal" ]]; then
                # Color code signal strength
                if [[ "$signal" -ge 70 ]]; then
                    echo -e "  Signal Strength: ${GREEN}${signal}%${NC}"
                elif [[ "$signal" -ge 50 ]]; then
                    echo -e "  Signal Strength: ${YELLOW}${signal}%${NC}"
                else
                    echo -e "  Signal Strength: ${RED}${signal}%${NC}"
                fi
            fi

            [[ -n "$rate" ]] && echo "  Link Rate: ${rate}"

            # Get security info
            local security
            security=$(nmcli -t -f IN-USE,SECURITY dev wifi | grep "^\*:" | cut -d: -f2)
            [[ -n "$security" ]] && echo "  Security: ${security}"

            # Check internet connectivity
            if ping -c 1 -W 2 8.8.8.8 &>/dev/null; then
                echo -e "  Internet: ${GREEN}Connected${NC}"
            else
                echo -e "  Internet: ${RED}No connectivity${NC}"
            fi
        fi

        echo
    done

    # Show available networks for the first interface
    if [[ ${#interfaces[@]} -gt 0 ]]; then
        local first_interface="${interfaces[0]}"
        echo "Available Networks (on ${first_interface}):"

        # Get available networks with signal strength
        local networks_info
        networks_info=$(nmcli -t -f SSID,SIGNAL,SECURITY dev wifi list ifname "$first_interface" 2>/dev/null | grep -v "^$" | sort -t: -k2 -nr | head -10)

        if [[ -n "$networks_info" ]]; then
            printf "  %-30s  %6s  %s\n" "SSID" "Signal" "Security"
            printf "  %-30s  %6s  %s\n" "----" "------" "--------"
            while IFS=: read -r ssid signal security; do
                if [[ -n "$ssid" ]]; then
                    # Color code signal strength
                    local signal_display
                    if [[ "$signal" -ge 70 ]]; then
                        signal_display="${GREEN}${signal}%${NC}"
                    elif [[ "$signal" -ge 50 ]]; then
                        signal_display="${YELLOW}${signal}%${NC}"
                    else
                        signal_display="${RED}${signal}%${NC}"
                    fi
                    printf "  %-30s  " "$ssid"
                    echo -e "${signal_display}    ${security}"
                fi
            done <<< "$networks_info"
        else
            echo "  No networks found"
        fi
    fi
}

#######################################
# Main execution function
# Parses arguments, validates inputs, handles status/connection workflows
# Globals:
#   All script globals
# Arguments:
#   Command line arguments
# Returns:
#   0 on success, exits with error code on failure
#######################################
main() {
    # Parse command line arguments
    while [[ $# -gt 0 ]]; do
        case $1 in
            -h|--help)
                show_help
                exit 0
                ;;
            -v|--verbose)
                VERBOSE=true
                shift
                ;;
            -i|--interface)
                INTERFACE="$2"
                shift 2
                ;;
            -s|--ssid)
                SSID="$2"
                shift 2
                ;;
            -p|--password)
                PASSWORD="$2"
                shift 2
                ;;
            --status)
                SHOW_STATUS=true
                shift
                ;;
            --non-interactive)
                NON_INTERACTIVE=true
                shift
                ;;
            *)
                error_exit "Unknown option: $1. Use --help for usage information."
                ;;
        esac
    done

    # Setup logging after parsing arguments (fixes verbose flag timing)
    setup_logging

    # Validate provided inputs
    if [[ -n "${INTERFACE}" ]] && ! validate_interface "${INTERFACE}"; then
        error_exit "Invalid interface name: ${INTERFACE}"
    fi

    if [[ -n "${SSID}" ]] && ! validate_ssid "${SSID}"; then
        error_exit "Invalid SSID: ${SSID}"
    fi

    if [[ -n "${PASSWORD}" ]] && ! validate_wifi_password "${PASSWORD}"; then
        error_exit "Invalid password (must be 8-63 characters)"
    fi

    # Show banner if available
    if [[ "$HAS_BANNER" == "true" ]]; then
        show_banner_with_title "WiFi Connection Manager" "network"
    else
        echo "DangerPrep WiFi Connection Manager v${SCRIPT_VERSION}"
        echo "================================================="
    fi

    # Handle status request
    if [[ "$SHOW_STATUS" == "true" ]]; then
        show_status
        exit 0
    fi

    # Check dependencies
    check_dependencies

    # Create lock file
    create_lock

    # Get WiFi interfaces if not specified
    if [[ -z "${INTERFACE}" ]]; then
        local interfaces_list
        if ! interfaces_list=$(get_wifi_interfaces); then
            error_exit "No WiFi interfaces found"
        fi

        local interfaces_array=()
        while IFS= read -r line; do
            [[ -n "${line}" ]] && interfaces_array+=("${line}")
        done <<< "${interfaces_list}"

        if [[ ${#interfaces_array[@]} -eq 1 ]]; then
            INTERFACE="${interfaces_array[0]}"
            log_info "Using WiFi interface: ${INTERFACE}"
        else
            if [[ "${NON_INTERACTIVE}" == "true" ]]; then
                error_exit "Multiple WiFi interfaces found. Please specify one with --interface"
            fi

            # Show connection information for all interfaces before selection
            echo
            echo "WiFi Interface Information:"
            echo "============================"
            for iface in "${interfaces_array[@]}"; do
                echo
                echo "Interface: ${iface}"

                # Use helper function for state
                local state
                if state=$(get_interface_state "${iface}"); then
                    # Color code the state
                    case "${state}" in
                        "connected")
                            echo -e "  State: ${GREEN}${state}${NC}"
                            ;;
                        "disconnected")
                            echo -e "  State: ${YELLOW}${state}${NC}"
                            ;;
                        "unavailable")
                            echo -e "  State: ${RED}${state}${NC}"
                            ;;
                        *)
                            echo "  State: ${state}"
                            ;;
                    esac

                    # Get current connection if connected
                    if [[ "${state}" == "connected" ]]; then
                        local iface_ssid
                        if iface_ssid=$(get_current_ssid "${iface}"); then
                            echo "  Connected to: ${iface_ssid}"
                        fi

                        # Get IP address (optimized single awk call)
                        local ip_address
                        ip_address=$(nmcli -t -f IP4.ADDRESS dev show "${iface}" 2>/dev/null | awk -F: '{print $2}' | awk -F/ '{print $1}')
                        [[ -n "${ip_address}" ]] && echo "  IP Address: ${ip_address}"

                        # Get signal strength (optimized)
                        local signal
                        signal=$(nmcli -t -f IN-USE,SIGNAL dev wifi 2>/dev/null | awk -F: '/^\*:/ {print $2}')
                        if [[ -n "${signal}" ]]; then
                            if [[ "${signal}" -ge 70 ]]; then
                                echo -e "  Signal: ${GREEN}${signal}%${NC}"
                            elif [[ "${signal}" -ge 50 ]]; then
                                echo -e "  Signal: ${YELLOW}${signal}%${NC}"
                            else
                                echo -e "  Signal: ${RED}${signal}%${NC}"
                            fi
                        fi
                    fi
                else
                    echo "  State: Unknown"
                fi
            done
            echo
            echo "============================"
            echo

            if [[ "${HAS_GUM_UTILS}" == "true" ]]; then
                INTERFACE=$(enhanced_choose "Select WiFi interface:" "${interfaces_array[@]}")
            else
                echo "Available WiFi interfaces:"
                for i in "${!interfaces_array[@]}"; do
                    echo "$((i+1)). ${interfaces_array[i]}"
                done
                read -r -p "Select interface (1-${#interfaces_array[@]}): " choice
                INTERFACE="${interfaces_array[$((choice-1))]}"
            fi

            [[ -z "${INTERFACE}" ]] && error_exit "No interface selected"
        fi
    fi

    # Detect current WiFi connection (optimized)
    local current_ssid=""
    local current_interface=""

    # Get currently active SSID using helper
    if current_ssid=$(get_current_ssid); then
        # Find which interface is connected (optimized with single nmcli call)
        current_interface=$(nmcli -t -f DEVICE,STATE device status 2>/dev/null | awk -F: '$2 == "connected" {print $1; exit}')

        if [[ -n "${current_interface}" ]]; then
            log_info "Currently connected to '${current_ssid}' on interface '${current_interface}'"
        fi
    fi

    # Scan for networks and get SSID if not specified
    if [[ -z "$SSID" ]]; then
        if [[ "$NON_INTERACTIVE" == "true" ]]; then
            error_exit "SSID not specified. Use --ssid in non-interactive mode"
        fi

        local networks
        if ! networks=$(scan_networks "$INTERFACE"); then
            error_exit "Failed to scan for networks"
        fi

        local networks_array=()
        while IFS= read -r line; do
            networks_array+=("$line")
        done <<< "$networks"

        if [[ "$HAS_GUM_UTILS" == "true" ]]; then
            SSID=$(enhanced_choose "Select network to connect to:" "${networks_array[@]}")
        else
            echo "Available networks:"
            for i in "${!networks_array[@]}"; do
                echo "$((i+1)). ${networks_array[i]}"
            done
            read -r -p "Select network (1-${#networks_array[@]}): " choice
            SSID="${networks_array[$((choice-1))]}"
        fi

        [[ -z "$SSID" ]] && error_exit "No network selected"
    fi

    # Get password if not specified
    if [[ -z "$PASSWORD" ]]; then
        if [[ "$NON_INTERACTIVE" == "true" ]]; then
            error_exit "Password not specified. Use --password in non-interactive mode"
        fi

        if [[ "$HAS_GUM_UTILS" == "true" ]]; then
            PASSWORD=$(enhanced_password "Enter WiFi password for '$SSID':")
        else
            read -r -s -p "Enter WiFi password for '$SSID': " PASSWORD
            echo
        fi

        [[ -z "$PASSWORD" ]] && error_exit "No password provided"
    fi

    # Connect to WiFi
    if connect_wifi "$INTERFACE" "$SSID" "$PASSWORD"; then
        if verify_connection "$INTERFACE" "$SSID"; then
            log_info "WiFi connection change completed successfully!"
        else
            error_exit "Connection verification failed"
        fi
    else
        error_exit "Failed to connect to WiFi network"
    fi
}

# Run main function if script is executed directly
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    main "$@"
fi
