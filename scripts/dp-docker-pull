#!/bin/bash
# DangerPrep Docker Image Pull Utility
# Recursively pulls all Docker images from compose files in the DangerPrep docker directory
# 
# Usage:
#   dp-docker-pull [OPTIONS]
#
# Options:
#   -h, --help       Show this help message
#   -v, --verbose    Enable verbose output
#   -d, --dry-run    Show what would be done without executing
#   -p, --parallel   Pull images in parallel (default: sequential)
#
# Dependencies:
#   - docker
#   - docker compose
#   - gum (for enhanced UI)

set -euo pipefail

# Script configuration
readonly SCRIPT_NAME="dp-docker-pull"
readonly SCRIPT_VERSION="1.0.0"
readonly DOCKER_ROOT="${DOCKER_ROOT:-/dangerprep/docker}"
readonly LOG_FILE="/var/log/dp-docker-pull.log"
LOCK_FILE="/var/run/dp-docker-pull.lock"

# Default options
VERBOSE=false
DRY_RUN=false
PARALLEL=false

# Colors for output
readonly RED='\033[0;31m'
readonly GREEN='\033[0;32m'
readonly YELLOW='\033[1;33m'
readonly BLUE='\033[0;34m'
readonly NC='\033[0m' # No Color

# Source shared utilities if available
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
SHARED_DIR="${SCRIPT_DIR}/shared"

if [[ -f "${SHARED_DIR}/gum-utils.sh" ]]; then
    source "${SHARED_DIR}/gum-utils.sh"
    HAS_GUM_UTILS=true
else
    HAS_GUM_UTILS=false
fi

if [[ -f "${SHARED_DIR}/banner.sh" ]]; then
    source "${SHARED_DIR}/banner.sh"
    HAS_BANNER=true
else
    HAS_BANNER=false
fi

# Logging functions
log() {
    local level="$1"
    shift
    local message="$*"
    local timestamp=$(date '+%Y-%m-%d %H:%M:%S')
    
    # Log to file (with fallback for permission issues)
    {
        if mkdir -p "$(dirname "$LOG_FILE")" 2>/dev/null && echo "[$timestamp] [$level] $message" >> "$LOG_FILE" 2>/dev/null; then
            : # Successfully logged to system log
        else
            # Fallback to user log directory
            local user_log_dir="$HOME/.local/share/dangerprep/logs"
            local user_log_file="$user_log_dir/$(basename "$LOG_FILE")"
            mkdir -p "$user_log_dir" 2>/dev/null || true
            echo "[$timestamp] [$level] $message" >> "$user_log_file" 2>/dev/null || true
        fi
    } 2>/dev/null
    
    # Log to console with colors
    case "$level" in
        "ERROR")
            echo -e "${RED}[ERROR]${NC} $message" >&2
            ;;
        "WARN")
            echo -e "${YELLOW}[WARN]${NC} $message" >&2
            ;;
        "INFO")
            echo -e "${GREEN}[INFO]${NC} $message"
            ;;
        "DEBUG")
            [[ "$VERBOSE" == "true" ]] && echo -e "${BLUE}[DEBUG]${NC} $message"
            ;;
    esac
}

log_info() { log "INFO" "$@"; }
log_warn() { log "WARN" "$@"; }
log_error() { log "ERROR" "$@"; }
log_debug() { log "DEBUG" "$@"; }

# Error handling
error_exit() {
    log_error "$@"
    cleanup
    exit 1
}

# Cleanup function
cleanup() {
    [[ -f "$LOCK_FILE" ]] && rm -f "$LOCK_FILE"
}

# Trap cleanup on exit
trap cleanup EXIT

# Show help
show_help() {
    cat << EOF
DangerPrep Docker Image Pull Utility v${SCRIPT_VERSION}

DESCRIPTION:
    Recursively finds all Docker Compose files in ${DOCKER_ROOT} and pulls
    all images to ensure they are up to date. Useful for maintenance and
    ensuring all services have the latest images available.

USAGE:
    $SCRIPT_NAME [OPTIONS]

OPTIONS:
    -h, --help       Show this help message and exit
    -v, --verbose    Enable verbose output and debugging
    -d, --dry-run    Show what would be done without executing
    -p, --parallel   Pull images in parallel (faster but more resource intensive)

EXAMPLES:
    $SCRIPT_NAME                    # Pull all images sequentially
    $SCRIPT_NAME --verbose          # Pull with detailed output
    $SCRIPT_NAME --dry-run          # Show what would be pulled
    $SCRIPT_NAME --parallel         # Pull images in parallel

DEPENDENCIES:
    - docker (Docker Engine)
    - docker compose (Docker Compose V2)
    - gum (for enhanced UI, optional)

LOGS:
    Operations are logged to: $LOG_FILE

EOF
}

# Check dependencies
check_dependencies() {
    local deps=("docker")
    local missing_deps=()
    
    for dep in "${deps[@]}"; do
        if ! command -v "$dep" >/dev/null 2>&1; then
            missing_deps+=("$dep")
        fi
    done
    
    # Check for docker compose (V2 syntax)
    if ! docker compose version >/dev/null 2>&1; then
        missing_deps+=("docker compose")
    fi
    
    if [[ ${#missing_deps[@]} -gt 0 ]]; then
        error_exit "Missing dependencies: ${missing_deps[*]}"
    fi
    
    # Check if Docker daemon is running
    if ! docker info >/dev/null 2>&1; then
        error_exit "Docker daemon is not running. Please start Docker first."
    fi
    
    log_debug "All dependencies satisfied"
}

# Create lock file
create_lock() {
    local lock_file="$LOCK_FILE"
    
    # Try to create lock file, fallback to user directory if needed
    {
        if ! echo $$ > "$lock_file" 2>/dev/null; then
            local user_lock_dir="$HOME/.local/share/dangerprep/locks"
            mkdir -p "$user_lock_dir" 2>/dev/null || true
            lock_file="$user_lock_dir/$(basename "$LOCK_FILE")"
        fi
    } 2>/dev/null
    
    if [[ -f "$lock_file" ]]; then
        local pid
        pid=$(cat "$lock_file" 2>/dev/null || echo "")
        if [[ -n "$pid" ]] && [[ "$pid" != "$$" ]] && kill -0 "$pid" 2>/dev/null; then
            error_exit "Another instance is already running (PID: $pid)"
        else
            [[ "$pid" != "$$" ]] && log_warn "Removing stale lock file"
            rm -f "$lock_file" 2>/dev/null || true
        fi
    fi
    
    if echo $$ > "$lock_file" 2>/dev/null; then
        # Update LOCK_FILE variable to point to the actual lock file used
        LOCK_FILE="$lock_file"
        log_debug "Created lock file: $LOCK_FILE"
    else
        log_warn "Could not create lock file, continuing without lock"
    fi
}

# Find all compose files
find_compose_files() {
    local compose_files=()
    
    if [[ ! -d "$DOCKER_ROOT" ]]; then
        error_exit "Docker root directory not found: $DOCKER_ROOT"
    fi
    
    log_info "Scanning for Docker Compose files in $DOCKER_ROOT"
    
    # Find all compose.yml and docker-compose.yml files
    while IFS= read -r file; do
        [[ -n "$file" ]] && compose_files+=("$file")
    done < <(find "$DOCKER_ROOT" -name "compose.yml" -o -name "docker-compose.yml" 2>/dev/null)
    
    if [[ ${#compose_files[@]} -eq 0 ]]; then
        log_warn "No Docker Compose files found in $DOCKER_ROOT"
        return 1
    fi
    
    log_info "Found ${#compose_files[@]} Docker Compose files"
    printf '%s\n' "${compose_files[@]}"
}

# Pull images from a compose file
pull_compose_images() {
    local compose_file="$1"
    local service_name
    service_name=$(basename "$(dirname "$compose_file")")
    
    log_info "Processing: $service_name ($compose_file)"
    
    if [[ "$DRY_RUN" == "true" ]]; then
        log_info "[DRY RUN] Would pull images for: $compose_file"
        return 0
    fi
    
    local compose_dir
    compose_dir=$(dirname "$compose_file")
    
    # Change to compose directory and pull images
    if (cd "$compose_dir" && docker compose pull 2>&1); then
        log_info "✓ Successfully pulled images for: $service_name"
        return 0
    else
        log_error "✗ Failed to pull images for: $service_name"
        return 1
    fi
}

# Main execution function
main() {
    # Parse command line arguments
    while [[ $# -gt 0 ]]; do
        case $1 in
            -h|--help)
                show_help
                exit 0
                ;;
            -v|--verbose)
                VERBOSE=true
                shift
                ;;
            -d|--dry-run)
                DRY_RUN=true
                shift
                ;;
            -p|--parallel)
                PARALLEL=true
                shift
                ;;
            *)
                error_exit "Unknown option: $1. Use --help for usage information."
                ;;
        esac
    done

    # Show banner if available
    # if [[ "$HAS_BANNER" == "true" ]]; then
    #     show_banner "$SCRIPT_NAME" "$SCRIPT_VERSION"
    # else
        echo "DangerPrep Docker Image Pull Utility v${SCRIPT_VERSION}"
        echo "=================================================="
    # fi

    # Check dependencies
    # check_dependencies  # Simplified for now

    # Create lock file
    create_lock

    # Find compose files
    local compose_files
    if ! compose_files=$(find_compose_files); then
        exit 0
    fi

    # Convert to array
    local compose_files_array=()
    while IFS= read -r line; do
        compose_files_array+=("$line")
    done <<< "$compose_files"

    log_info "Starting image pull process..."
    [[ "$DRY_RUN" == "true" ]] && log_info "DRY RUN MODE - No actual pulls will be performed"

    local success_count=0
    local failure_count=0

    # Process compose files
    for compose_file in "${compose_files_array[@]}"; do
        if [[ "$HAS_GUM_UTILS" == "true" && "$DRY_RUN" == "false" ]]; then
            if enhanced_spin "Pulling images for $(basename "$(dirname "$compose_file")")" pull_compose_images "$compose_file"; then
                ((success_count++))
            else
                ((failure_count++))
            fi
        else
            if pull_compose_images "$compose_file"; then
                ((success_count++))
            else
                ((failure_count++))
            fi
        fi
    done

    # Summary
    echo
    log_info "Image pull completed!"
    log_info "Successfully processed: $success_count services"
    [[ $failure_count -gt 0 ]] && log_warn "Failed to process: $failure_count services"

    if [[ $failure_count -gt 0 ]]; then
        log_warn "Some services failed to pull images. Check logs for details: $LOG_FILE"
        exit 1
    fi

    log_info "All Docker images are now up to date!"
}

# Run main function if script is executed directly
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    main "$@"
fi
