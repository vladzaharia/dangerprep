#!/bin/bash
# DangerPrep WiFi Hotspot Setup
# Creates a complete WiFi hotspot with DHCP, DNS, forwarding, and firewall rules
# 
# Usage:
#   dangerprep-wifi-hotspot [OPTIONS]
#
# Options:
#   -h, --help       Show this help message
#   -v, --verbose    Enable verbose output
#   -d, --disable    Disable and remove hotspot
#   -s, --status     Show hotspot status
#   --non-interactive  Run without prompts (uses defaults)
#
# Dependencies:
#   - hostapd (WiFi Access Point daemon)
#   - dnsmasq (DHCP and DNS server)
#   - iptables (firewall rules)
#   - systemd (service management)

set -euo pipefail

# Script configuration
readonly SCRIPT_NAME="dp-wifi-hotspot"
readonly SCRIPT_VERSION="1.0.0"
readonly LOG_FILE="/var/log/dp-wifi-hotspot.log"
readonly LOCK_FILE_DEFAULT="/var/run/dp-wifi-hotspot.lock"

# Actual lock file path (may be changed to fallback location)
ACTUAL_LOCK_FILE=""

# Configuration files
readonly HOSTAPD_CONF="/etc/hostapd/hostapd.conf"
readonly DNSMASQ_CONF="/etc/dnsmasq.d/dangerprep-hotspot.conf"
readonly SYSTEMD_RESOLVED_CONF="/etc/systemd/resolved.conf"
readonly SYSCTL_CONF="/etc/sysctl.d/99-dangerprep-hotspot.conf"

# Default hotspot configuration
readonly DEFAULT_SSID="DangerPrep-Hotspot"
readonly DEFAULT_PASSWORD="dangerprep123"
readonly DEFAULT_INTERFACE="wlan0"
readonly DEFAULT_IP="192.168.4.1"
readonly DEFAULT_DHCP_START="192.168.4.10"
readonly DEFAULT_DHCP_END="192.168.4.50"
readonly DEFAULT_CHANNEL="7"

# Options
VERBOSE=false
DISABLE_HOTSPOT=false
SHOW_STATUS=false
NON_INTERACTIVE=false

# Colors for output
readonly RED='\033[0;31m'
readonly GREEN='\033[0;32m'
readonly YELLOW='\033[1;33m'
readonly BLUE='\033[0;34m'
readonly NC='\033[0m' # No Color

# Source shared utilities if available
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
SHARED_DIR="${SCRIPT_DIR}/shared"

if [[ -f "${SHARED_DIR}/gum-utils.sh" ]]; then
    # shellcheck source=scripts/shared/gum-utils.sh
    source "${SHARED_DIR}/gum-utils.sh"
    HAS_GUM_UTILS=true
else
    HAS_GUM_UTILS=false
fi

if [[ -f "${SHARED_DIR}/banner.sh" ]]; then
    # shellcheck source=scripts/shared/banner.sh
    source "${SHARED_DIR}/banner.sh"
    HAS_BANNER=true
else
    HAS_BANNER=false
fi

# Use enhanced logging from gum-utils if available, fallback to basic logging
if [[ "$HAS_GUM_UTILS" == "true" ]]; then
    # Set DEBUG environment variable for gum-utils debug logging
    [[ "$VERBOSE" == "true" ]] && export DEBUG=true

    # Use enhanced logging functions from gum-utils.sh
    # These are already defined in gum-utils.sh: log_info, log_warn, log_error, log_debug, log_success
    :
else
    # Fallback logging functions when gum-utils is not available
    log() {
        local level="$1"
        shift
        local message="$*"
        local timestamp
        timestamp=$(date '+%Y-%m-%d %H:%M:%S')

        # Log to file (with fallback for permission issues)
        if mkdir -p "$(dirname "${LOG_FILE}")" 2>/dev/null && echo "[${timestamp}] [${level}] ${message}" >> "${LOG_FILE}" 2>/dev/null; then
            : # Successfully logged to system log
        else
            # Fallback to user log directory
            local user_log_dir="${HOME}/.local/share/dangerprep/logs"
            local user_log_file
            user_log_file="${user_log_dir}/$(basename "${LOG_FILE}")"
            mkdir -p "${user_log_dir}" 2>/dev/null || true
            echo "[${timestamp}] [${level}] ${message}" >> "${user_log_file}" 2>/dev/null || true
        fi

        # Log to console with colors
        case "${level}" in
            "ERROR")
                echo -e "${RED}[ERROR]${NC} ${message}" >&2
                ;;
            "WARN")
                echo -e "${YELLOW}[WARN]${NC} ${message}" >&2
                ;;
            "INFO")
                echo -e "${GREEN}[INFO]${NC} ${message}"
                ;;
            "DEBUG")
                [[ "${VERBOSE}" == "true" ]] && echo -e "${BLUE}[DEBUG]${NC} ${message}"
                ;;
        esac
    }

    log_info() { log "INFO" "$@"; }
    log_warn() { log "WARN" "$@"; }
    log_error() { log "ERROR" "$@"; }
    log_debug() { log "DEBUG" "$@"; }
fi

# Error handling
error_exit() {
    log_error "$@"
    cleanup
    exit 1
}

# Cleanup function
cleanup() {
    [[ -n "${ACTUAL_LOCK_FILE}" ]] && [[ -f "${ACTUAL_LOCK_FILE}" ]] && rm -f "${ACTUAL_LOCK_FILE}"
}

# Trap cleanup on exit
trap cleanup EXIT

# Show help
show_help() {
    cat << EOF
DangerPrep WiFi Hotspot Setup v${SCRIPT_VERSION}

DESCRIPTION:
    Sets up a complete WiFi hotspot with DHCP, DNS, IP forwarding, and firewall
    rules. Handles systemd-resolved conflicts and provides a fully functional
    access point for emergency networking scenarios.

USAGE:
    ${SCRIPT_NAME} [OPTIONS]

OPTIONS:
    -h, --help              Show this help message and exit
    -v, --verbose           Enable verbose output and debugging
    -d, --disable           Disable and remove hotspot configuration
    -s, --status            Show current hotspot status
    --non-interactive       Run without prompts (uses default configuration)

EXAMPLES:
    ${SCRIPT_NAME}                    # Interactive setup
    ${SCRIPT_NAME} --verbose          # Setup with detailed output
    ${SCRIPT_NAME} --status           # Check hotspot status
    ${SCRIPT_NAME} --disable          # Remove hotspot configuration
    ${SCRIPT_NAME} --non-interactive  # Setup with defaults

DEFAULT CONFIGURATION:
    SSID: ${DEFAULT_SSID}
    Password: ${DEFAULT_PASSWORD}
    Interface: ${DEFAULT_INTERFACE}
    IP Address: ${DEFAULT_IP}
    DHCP Range: ${DEFAULT_DHCP_START} - ${DEFAULT_DHCP_END}
    Channel: ${DEFAULT_CHANNEL}

DEPENDENCIES:
    - hostapd (WiFi Access Point daemon)
    - dnsmasq (DHCP and DNS server)
    - iptables (firewall and NAT rules)
    - systemd (service management)

LOGS:
    Operations are logged to: ${LOG_FILE}

NOTES:
    - Requires root privileges
    - Modifies system network configuration
    - Configures systemd-resolved to avoid port conflicts
    - Sets up IP forwarding and NAT rules

EOF
}

# Check if running as root
check_root() {
    if [[ ${EUID} -ne 0 ]]; then
        error_exit "This script must be run as root. Use: sudo ${0}"
    fi
}

# Check dependencies
check_dependencies() {
    local deps=("hostapd" "dnsmasq" "iptables" "systemctl")
    local missing_deps=()
    
    for dep in "${deps[@]}"; do
        if ! command -v "$dep" >/dev/null 2>&1; then
            missing_deps+=("$dep")
        fi
    done
    
    if [[ ${#missing_deps[@]} -gt 0 ]]; then
        log_warn "Missing dependencies: ${missing_deps[*]}"
        log_info "Installing missing packages..."
        
        # Install missing packages
        if command -v apt-get >/dev/null 2>&1; then
            apt-get update
            for dep in "${missing_deps[@]}"; do
                case "$dep" in
                    "systemctl")
                        # systemctl is part of systemd, usually already installed
                        continue
                        ;;
                    *)
                        apt-get install -y "$dep"
                        ;;
                esac
            done
        else
            error_exit "Package manager not found. Please install: ${missing_deps[*]}"
        fi
    fi
    
    log_debug "All dependencies satisfied"
}

# Create lock file
create_lock() {
    local lock_file="${LOCK_FILE_DEFAULT}"

    # Try to create lock file, fallback to user directory if needed
    if ! echo "$$" > "${lock_file}" 2>/dev/null; then
        local user_lock_dir="${HOME}/.local/share/dangerprep/locks"
        mkdir -p "${user_lock_dir}" 2>/dev/null || true
        lock_file="${user_lock_dir}/$(basename "${LOCK_FILE_DEFAULT}")"
    fi

    if [[ -f "${lock_file}" ]]; then
        local pid
        pid=$(cat "${lock_file}" 2>/dev/null || echo "")
        if [[ -n "${pid}" ]] && [[ "${pid}" != "$$" ]] && kill -0 "${pid}" 2>/dev/null; then
            error_exit "Another instance is already running (PID: ${pid})"
        else
            [[ "${pid}" != "$$" ]] && log_warn "Removing stale lock file"
            rm -f "${lock_file}" 2>/dev/null || true
        fi
    fi

    if echo "$$" > "${lock_file}" 2>/dev/null; then
        # Update ACTUAL_LOCK_FILE variable to point to the actual lock file used
        ACTUAL_LOCK_FILE="${lock_file}"
        log_debug "Created lock file: ${ACTUAL_LOCK_FILE}"
    else
        log_warn "Could not create lock file, continuing without lock"
    fi
}

# Get available WiFi interfaces
get_wifi_interfaces() {
    local interfaces=()
    
    # Get WiFi interfaces that support AP mode
    while IFS= read -r line; do
        if [[ -n "$line" ]]; then
            # Check if interface supports AP mode
            if iw "$line" info 2>/dev/null | grep -q "AP"; then
                interfaces+=("$line")
            fi
        fi
    done < <(iw dev 2>/dev/null | grep Interface | awk '{print $2}')
    
    if [[ ${#interfaces[@]} -eq 0 ]]; then
        # Fallback: get all wireless interfaces using glob
        for iface in /sys/class/net/wl*; do
            if [[ -e "${iface}" ]]; then
                interfaces+=("$(basename "${iface}")")
            fi
        done
    fi
    
    printf '%s\n' "${interfaces[@]}"
}

# Get hotspot configuration
get_hotspot_config() {
    local config=()

    # Check for existing hotspot configuration
    local existing_ssid=""
    local existing_interface=""
    local existing_channel=""
    local existing_ip=""
    local has_existing_config=false

    if [[ -f "$HOSTAPD_CONF" ]]; then
        existing_ssid=$(grep "^ssid=" "$HOSTAPD_CONF" 2>/dev/null | cut -d= -f2 || echo "")
        existing_interface=$(grep "^interface=" "$HOSTAPD_CONF" 2>/dev/null | cut -d= -f2 || echo "")
        existing_channel=$(grep "^channel=" "$HOSTAPD_CONF" 2>/dev/null | cut -d= -f2 || echo "")

        if [[ -n "$existing_ssid" ]] && [[ -n "$existing_interface" ]]; then
            has_existing_config=true
            log_info "Found existing hotspot configuration:"
            log_info "  SSID: $existing_ssid"
            log_info "  Interface: $existing_interface"
            log_info "  Channel: $existing_channel"

            # Check if hotspot is currently running
            if systemctl is-active --quiet hostapd; then
                log_info "  Status: ${GREEN}Running${NC}"
            else
                log_info "  Status: ${YELLOW}Stopped${NC}"
            fi
        fi
    fi

    if [[ "$NON_INTERACTIVE" == "true" ]]; then
        # Use existing config if available, otherwise use defaults
        if [[ "$has_existing_config" == "true" ]]; then
            config=(
                "$existing_interface"
                "$existing_ssid"
                "$DEFAULT_PASSWORD"  # Can't retrieve password from config
                "${existing_ip:-$DEFAULT_IP}"
                "$DEFAULT_DHCP_START"
                "$DEFAULT_DHCP_END"
                "${existing_channel:-$DEFAULT_CHANNEL}"
            )
        else
            config=(
                "$DEFAULT_INTERFACE"
                "$DEFAULT_SSID"
                "$DEFAULT_PASSWORD"
                "$DEFAULT_IP"
                "$DEFAULT_DHCP_START"
                "$DEFAULT_DHCP_END"
                "$DEFAULT_CHANNEL"
            )
        fi
    else
        # Get WiFi interface
        local interfaces
        interfaces=$(get_wifi_interfaces)
        local interfaces_array=()
        
        while IFS= read -r line; do
            [[ -n "$line" ]] && interfaces_array+=("$line")
        done <<< "$interfaces"
        
        if [[ ${#interfaces_array[@]} -eq 0 ]]; then
            error_exit "No WiFi interfaces found that support AP mode"
        fi
        
        local selected_interface
        # Use existing interface if available and valid
        local interface_list=" ${interfaces_array[*]} "
        if [[ -n "$existing_interface" ]] && [[ "${interface_list}" =~ \ ${existing_interface}\  ]]; then
            selected_interface="$existing_interface"
            log_info "Using existing WiFi interface: $selected_interface"
        elif [[ ${#interfaces_array[@]} -eq 1 ]]; then
            selected_interface="${interfaces_array[0]}"
            log_info "Using WiFi interface: $selected_interface"
        else
            if [[ "$HAS_GUM_UTILS" == "true" ]]; then
                selected_interface=$(enhanced_choose "Select WiFi interface for hotspot:" "${interfaces_array[@]}")
            else
                echo "Available WiFi interfaces:"
                for i in "${!interfaces_array[@]}"; do
                    echo "  $((i+1)). ${interfaces_array[i]}"
                done
                echo -n "Select interface (1-${#interfaces_array[@]}): "
                read -r choice
                if [[ "$choice" =~ ^[0-9]+$ ]] && [[ $choice -ge 1 ]] && [[ $choice -le ${#interfaces_array[@]} ]]; then
                    selected_interface="${interfaces_array[$((choice-1))]}"
                else
                    error_exit "Invalid selection"
                fi
            fi
        fi
        
        # Get other configuration
        local ssid password ip_address dhcp_start dhcp_end channel

        # Use existing config as defaults if available
        local default_ssid="${existing_ssid:-$DEFAULT_SSID}"
        local default_channel="${existing_channel:-$DEFAULT_CHANNEL}"
        local default_ip="${existing_ip:-$DEFAULT_IP}"

        if [[ "$HAS_GUM_UTILS" == "true" ]]; then
            ssid=$(enhanced_input "Enter hotspot SSID:" "$default_ssid")
            password=$(enhanced_password "Enter hotspot password (min 8 chars):")
            ip_address=$(enhanced_input "Enter hotspot IP address:" "$default_ip")
            dhcp_start=$(enhanced_input "Enter DHCP range start:" "$DEFAULT_DHCP_START")
            dhcp_end=$(enhanced_input "Enter DHCP range end:" "$DEFAULT_DHCP_END")
            channel=$(enhanced_input "Enter WiFi channel (1-11):" "$default_channel")
        else
            echo -n "Enter hotspot SSID [$default_ssid]: "
            read -r ssid
            [[ -z "$ssid" ]] && ssid="$default_ssid"

            echo -n "Enter hotspot password (min 8 chars): "
            read -rs password
            echo
            [[ -z "$password" ]] && password="$DEFAULT_PASSWORD"

            echo -n "Enter hotspot IP address [$default_ip]: "
            read -r ip_address
            [[ -z "$ip_address" ]] && ip_address="$default_ip"

            echo -n "Enter DHCP range start [$DEFAULT_DHCP_START]: "
            read -r dhcp_start
            [[ -z "$dhcp_start" ]] && dhcp_start="$DEFAULT_DHCP_START"

            echo -n "Enter DHCP range end [$DEFAULT_DHCP_END]: "
            read -r dhcp_end
            [[ -z "$dhcp_end" ]] && dhcp_end="$DEFAULT_DHCP_END"

            echo -n "Enter WiFi channel (1-11) [$default_channel]: "
            read -r channel
            [[ -z "$channel" ]] && channel="$default_channel"
        fi
        
        # Validate password length
        if [[ ${#password} -lt 8 ]]; then
            error_exit "Password must be at least 8 characters long"
        fi
        
        config=(
            "$selected_interface"
            "$ssid"
            "$password"
            "$ip_address"
            "$dhcp_start"
            "$dhcp_end"
            "$channel"
        )
    fi
    
    printf '%s\n' "${config[@]}"
}

# Configure systemd-resolved to avoid port 53 conflicts
configure_systemd_resolved() {
    log_info "Configuring systemd-resolved to avoid port conflicts..."
    
    # Backup original configuration
    if [[ -f "$SYSTEMD_RESOLVED_CONF" ]] && [[ ! -f "${SYSTEMD_RESOLVED_CONF}.backup" ]]; then
        cp "$SYSTEMD_RESOLVED_CONF" "${SYSTEMD_RESOLVED_CONF}.backup"
        log_debug "Backed up systemd-resolved configuration"
    fi
    
    # Configure systemd-resolved
    cat > "$SYSTEMD_RESOLVED_CONF" << EOF
# DangerPrep WiFi Hotspot Configuration
# Modified to avoid port 53 conflicts with dnsmasq

[Resolve]
DNS=8.8.8.8 1.1.1.1
#FallbackDNS=
#Domains=
#LLMNR=yes
#MulticastDNS=yes
#DNSSEC=yes
#DNSOverTLS=no
#Cache=yes
#CacheFromLocalhost=no
DNSStubListener=no
#DNSStubListenerExtra=
#ReadEtcHosts=yes
#ResolveUnicastSingleLabel=no
EOF
    
    # Restart systemd-resolved
    systemctl restart systemd-resolved
    log_info "systemd-resolved configured and restarted"
}

# Configure hostapd
configure_hostapd() {
    local interface="$1"
    local ssid="$2"
    local password="$3"
    local channel="$4"
    
    log_info "Configuring hostapd..."
    
    # Create hostapd configuration directory
    mkdir -p "$(dirname "$HOSTAPD_CONF")"
    
    # Backup original configuration if it exists
    if [[ -f "$HOSTAPD_CONF" ]] && [[ ! -f "${HOSTAPD_CONF}.backup" ]]; then
        cp "$HOSTAPD_CONF" "${HOSTAPD_CONF}.backup"
        log_debug "Backed up hostapd configuration"
    fi
    
    # Create hostapd configuration
    cat > "$HOSTAPD_CONF" << EOF
# DangerPrep WiFi Hotspot Configuration
# Generated by $SCRIPT_NAME v$SCRIPT_VERSION

# Interface configuration
interface=$interface
driver=nl80211

# Network configuration
ssid=$ssid
hw_mode=g
channel=$channel
wmm_enabled=0
macaddr_acl=0
auth_algs=1
ignore_broadcast_ssid=0

# Security configuration
wpa=2
wpa_passphrase=$password
wpa_key_mgmt=WPA-PSK
wpa_pairwise=TKIP
rsn_pairwise=CCMP

# Additional settings for better compatibility
ieee80211n=1
ht_capab=[HT40][SHORT-GI-20][DSSS_CCK-40]
country_code=US
EOF
    
    log_info "hostapd configuration created"
}

# Configure dnsmasq
configure_dnsmasq() {
    local interface="$1"
    local ip_address="$2"
    local dhcp_start="$3"
    local dhcp_end="$4"

    log_info "Configuring dnsmasq..."

    # Create dnsmasq configuration directory
    mkdir -p "$(dirname "$DNSMASQ_CONF")"

    # Create dnsmasq configuration for hotspot
    cat > "$DNSMASQ_CONF" << EOF
# DangerPrep WiFi Hotspot DHCP and DNS Configuration
# Generated by $SCRIPT_NAME v$SCRIPT_VERSION

# Interface configuration
interface=$interface
bind-interfaces

# DHCP configuration
dhcp-range=$dhcp_start,$dhcp_end,255.255.255.0,24h
dhcp-option=3,$ip_address
dhcp-option=6,$ip_address

# DNS configuration
server=8.8.8.8
server=1.1.1.1
domain-needed
bogus-priv
no-resolv

# Additional settings
expand-hosts
cache-size=1000
local-ttl=300

# Log queries for debugging (comment out for production)
# log-queries
# log-dhcp
EOF

    log_info "dnsmasq configuration created"
}

# Configure IP forwarding
configure_ip_forwarding() {
    log_info "Configuring IP forwarding..."

    # Enable IP forwarding in sysctl
    cat > "$SYSCTL_CONF" << EOF
# DangerPrep WiFi Hotspot IP Forwarding Configuration
# Generated by $SCRIPT_NAME v$SCRIPT_VERSION

# Enable IP forwarding for hotspot
net.ipv4.ip_forward=1
net.ipv6.conf.all.forwarding=1
EOF

    # Apply sysctl settings
    sysctl -p "$SYSCTL_CONF"

    log_info "IP forwarding enabled"
}

# Configure firewall rules
configure_firewall() {
    local interface="$1"
    local ip_address="$2"

    log_info "Configuring firewall rules..."

    # Get the default route interface (usually for internet connection)
    local wan_interface
    wan_interface=$(ip route | grep default | awk '{print $5}' | head -1)

    if [[ -z "$wan_interface" ]]; then
        log_warn "No default route found. NAT rules may not work properly."
        wan_interface="eth0"  # Fallback
    fi

    log_debug "Using WAN interface: $wan_interface"

    # Configure iptables rules for NAT and forwarding

    # Allow traffic on loopback
    iptables -A INPUT -i lo -j ACCEPT
    iptables -A OUTPUT -o lo -j ACCEPT

    # Allow established and related connections
    iptables -A INPUT -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT
    iptables -A FORWARD -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT

    # Allow traffic from hotspot interface
    iptables -A INPUT -i "$interface" -j ACCEPT
    iptables -A FORWARD -i "$interface" -o "$wan_interface" -j ACCEPT

    # Enable NAT for hotspot traffic
    iptables -t nat -A POSTROUTING -o "$wan_interface" -j MASQUERADE

    # Allow DHCP traffic
    iptables -A INPUT -i "$interface" -p udp --dport 67 -j ACCEPT
    iptables -A INPUT -i "$interface" -p udp --dport 53 -j ACCEPT
    iptables -A INPUT -i "$interface" -p tcp --dport 53 -j ACCEPT

    # Save iptables rules
    if command -v iptables-save >/dev/null 2>&1; then
        iptables-save > /etc/iptables/rules.v4 2>/dev/null || true
    fi

    log_info "Firewall rules configured"
}

# Configure network interface
configure_interface() {
    local interface="$1"
    local ip_address="$2"

    log_info "Configuring network interface $interface..."

    # Bring interface down
    ip link set "$interface" down 2>/dev/null || true

    # Set interface IP address
    ip addr flush dev "$interface" 2>/dev/null || true
    ip addr add "$ip_address/24" dev "$interface"

    # Bring interface up
    ip link set "$interface" up

    log_info "Interface $interface configured with IP $ip_address"
}

# Start services
start_services() {
    log_info "Starting hotspot services..."

    # Stop services first to ensure clean start
    systemctl stop hostapd 2>/dev/null || true
    systemctl stop dnsmasq 2>/dev/null || true

    # Start and enable services
    systemctl enable hostapd
    systemctl enable dnsmasq

    systemctl start hostapd
    systemctl start dnsmasq

    # Wait a moment and check status
    sleep 2

    if systemctl is-active --quiet hostapd && systemctl is-active --quiet dnsmasq; then
        log_info "✓ Hotspot services started successfully"
        return 0
    else
        log_error "✗ Failed to start hotspot services"
        return 1
    fi
}

# Show hotspot status
show_status() {
    echo "DangerPrep WiFi Hotspot Status"
    echo "=============================="
    echo

    # Check service status
    echo "Service Status:"
    if systemctl is-active --quiet hostapd; then
        echo "  hostapd: ${GREEN}Running${NC}"
    else
        echo "  hostapd: ${RED}Stopped${NC}"
    fi

    if systemctl is-active --quiet dnsmasq; then
        echo "  dnsmasq: ${GREEN}Running${NC}"
    else
        echo "  dnsmasq: ${RED}Stopped${NC}"
    fi

    echo

    # Show configuration if hostapd is running
    if systemctl is-active --quiet hostapd && [[ -f "$HOSTAPD_CONF" ]]; then
        echo "Hotspot Configuration:"
        local ssid interface channel
        ssid=$(grep "^ssid=" "$HOSTAPD_CONF" 2>/dev/null | cut -d= -f2 || echo "Unknown")
        interface=$(grep "^interface=" "$HOSTAPD_CONF" 2>/dev/null | cut -d= -f2 || echo "Unknown")
        channel=$(grep "^channel=" "$HOSTAPD_CONF" 2>/dev/null | cut -d= -f2 || echo "Unknown")

        echo "  SSID: $ssid"
        echo "  Interface: $interface"
        echo "  Channel: $channel"

        # Show interface IP
        if [[ "$interface" != "Unknown" ]]; then
            local ip_addr
            ip_addr=$(ip addr show "$interface" 2>/dev/null | grep "inet " | awk '{print $2}' | cut -d/ -f1 || echo "Not configured")
            echo "  IP Address: $ip_addr"
        fi
    fi

    echo

    # Show connected clients if possible
    if [[ -f "/var/lib/dhcp/dhcpd.leases" ]]; then
        local client_count
        client_count=$(grep -c "binding state active" /var/lib/dhcp/dhcpd.leases 2>/dev/null || echo "0")
        echo "Connected Clients: $client_count"
    fi
}

# Disable hotspot
disable_hotspot() {
    log_info "Disabling WiFi hotspot..."

    # Stop services
    systemctl stop hostapd 2>/dev/null || true
    systemctl stop dnsmasq 2>/dev/null || true
    systemctl disable hostapd 2>/dev/null || true
    systemctl disable dnsmasq 2>/dev/null || true

    # Remove configuration files
    [[ -f "$HOSTAPD_CONF" ]] && rm -f "$HOSTAPD_CONF"
    [[ -f "$DNSMASQ_CONF" ]] && rm -f "$DNSMASQ_CONF"
    [[ -f "$SYSCTL_CONF" ]] && rm -f "$SYSCTL_CONF"

    # Restore systemd-resolved configuration
    if [[ -f "${SYSTEMD_RESOLVED_CONF}.backup" ]]; then
        mv "${SYSTEMD_RESOLVED_CONF}.backup" "$SYSTEMD_RESOLVED_CONF"
        systemctl restart systemd-resolved
        log_info "systemd-resolved configuration restored"
    fi

    # Remove firewall rules (basic cleanup)
    iptables -F 2>/dev/null || true
    iptables -t nat -F 2>/dev/null || true

    # Disable IP forwarding
    sysctl -w net.ipv4.ip_forward=0 >/dev/null 2>&1 || true

    log_info "WiFi hotspot disabled and configuration removed"
}

# Main execution function
main() {
    # Parse command line arguments
    while [[ $# -gt 0 ]]; do
        case $1 in
            -h|--help)
                show_help
                exit 0
                ;;
            -v|--verbose)
                VERBOSE=true
                shift
                ;;
            -d|--disable)
                DISABLE_HOTSPOT=true
                shift
                ;;
            -s|--status)
                SHOW_STATUS=true
                shift
                ;;
            --non-interactive)
                NON_INTERACTIVE=true
                shift
                ;;
            *)
                error_exit "Unknown option: $1. Use --help for usage information."
                ;;
        esac
    done

    # Check root privileges
    check_root

    # Show banner if available
    if [[ "$HAS_BANNER" == "true" ]]; then
        show_banner_with_title "WiFi Hotspot Setup" "network"
    else
        echo "DangerPrep WiFi Hotspot Setup v${SCRIPT_VERSION}"
        echo "=============================================="
    fi

    # Handle status request
    if [[ "$SHOW_STATUS" == "true" ]]; then
        show_status
        exit 0
    fi

    # Handle disable request
    if [[ "$DISABLE_HOTSPOT" == "true" ]]; then
        create_lock
        disable_hotspot
        exit 0
    fi

    # Check dependencies
    check_dependencies

    # Create lock file
    create_lock

    # Get hotspot configuration
    local config
    config=$(get_hotspot_config)
    local config_array=()

    while IFS= read -r line; do
        config_array+=("$line")
    done <<< "$config"

    local interface="${config_array[0]}"
    local ssid="${config_array[1]}"
    local password="${config_array[2]}"
    local ip_address="${config_array[3]}"
    local dhcp_start="${config_array[4]}"
    local dhcp_end="${config_array[5]}"
    local channel="${config_array[6]}"

    log_info "Setting up WiFi hotspot with the following configuration:"
    log_info "  Interface: $interface"
    log_info "  SSID: $ssid"
    log_info "  IP Address: $ip_address"
    log_info "  DHCP Range: $dhcp_start - $dhcp_end"
    log_info "  Channel: $channel"

    # Configure system components
    configure_systemd_resolved
    configure_hostapd "$interface" "$ssid" "$password" "$channel"
    configure_dnsmasq "$interface" "$ip_address" "$dhcp_start" "$dhcp_end"
    configure_ip_forwarding
    configure_interface "$interface" "$ip_address"
    configure_firewall "$interface" "$ip_address"

    # Start services
    if start_services; then
        echo
        log_info "✓ WiFi hotspot setup completed successfully!"
        log_info "  SSID: $ssid"
        log_info "  Password: $password"
        log_info "  IP Address: $ip_address"
        echo
        log_info "Use '$SCRIPT_NAME --status' to check hotspot status"
        log_info "Use '$SCRIPT_NAME --disable' to remove hotspot configuration"
    else
        error_exit "Failed to start hotspot services. Check logs for details."
    fi
}

# Run main function if script is executed directly
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    main "$@"
fi
