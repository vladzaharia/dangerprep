import { writeFile, chmod } from 'fs/promises';
import type { ContentAnalysis } from '../core/analyzer.js';
import { getConfig } from '../config/loader.js';
import { join, basename } from 'path';

export class RsyncScriptExporter {
  private config = getConfig();

  /**
   * Export sync script for copying found content (includes both rsync and Kiwix downloads)
   */
  async export(
    analyses: ContentAnalysis[],
    outputPath: string,
    destination: string
  ): Promise<void> {
    // Include found items and items with size > 0 (includes Kiwix items)
    const itemsToSync = analyses.filter(a => a.status === 'found' && a.size_gb > 0);
    const scriptContent = this.generateSyncScript(itemsToSync, destination);

    // Write script file
    await writeFile(outputPath, scriptContent, 'utf-8');

    // Make script executable
    await chmod(outputPath, 0o755);
  }

  /**
   * Generate the complete sync script content (includes both rsync and Kiwix)
   */
  private generateSyncScript(items: ContentAnalysis[], destination: string): string {

    const lines: string[] = [];
    
    // Script header
    lines.push('#!/bin/bash');
    lines.push('');
    lines.push('# Media Collection Sync Script');
    lines.push('# Handles both NFS content (rsync) and Kiwix content (downloads)');
    lines.push('# Generated by Media Collection Manager');
    lines.push(`# Generated on: ${new Date().toISOString()}`);
    lines.push(`# Total items to sync: ${items.length}`);
    lines.push(`# Destination: ${destination}`);
    lines.push('');
    lines.push('set -e  # Exit on any error');
    lines.push('');
    
    // Configuration
    lines.push('# Configuration');
    lines.push(`DESTINATION="${destination}"`);
    lines.push(`RSYNC_OPTIONS="${this.config.rsync_config.options.join(' ')}"`);
    lines.push('');
    
    // Statistics
    const totalSize = items.reduce((sum, item) => sum + item.size_gb, 0);
    lines.push('# Collection Statistics');
    lines.push(`# Total Items: ${items.length}`);
    lines.push(`# Total Size: ${totalSize.toFixed(2)} GB`);
    lines.push('');
    
    // Functions
    lines.push('# Helper functions');
    lines.push('log_info() {');
    lines.push('    echo "[$(date \'%Y-%m-%d %H:%M:%S\')] INFO: $1"');
    lines.push('}');
    lines.push('');
    lines.push('log_error() {');
    lines.push('    echo "[$(date \'%Y-%m-%d %H:%M:%S\')] ERROR: $1" >&2');
    lines.push('}');
    lines.push('');
    lines.push('check_space() {');
    lines.push('    local required_gb=$1');
    lines.push('    local available_gb=$(df "$DESTINATION" | awk \'NR==2 {print int($4/1024/1024)}\')');
    lines.push('    if [ "$available_gb" -lt "$required_gb" ]; then');
    lines.push('        log_error "Insufficient space: ${required_gb}GB required, ${available_gb}GB available"');
    lines.push('        return 1');
    lines.push('    fi');
    lines.push('    return 0');
    lines.push('}');
    lines.push('');
    
    // Pre-flight checks
    lines.push('# Pre-flight checks');
    lines.push('log_info "Starting media collection sync"');
    lines.push('log_info "Destination: $DESTINATION"');
    lines.push('');
    lines.push('# Check if destination exists');
    lines.push('if [ ! -d "$DESTINATION" ]; then');
    lines.push('    log_info "Creating destination directory: $DESTINATION"');
    lines.push('    mkdir -p "$DESTINATION"');
    lines.push('fi');
    lines.push('');
    lines.push('# Check available space');
    lines.push(`if ! check_space ${Math.ceil(totalSize)}; then`);
    lines.push('    exit 1');
    lines.push('fi');
    lines.push('');
    
    // Progress tracking
    lines.push('# Progress tracking');
    lines.push('TOTAL_ITEMS=' + items.length);
    lines.push('CURRENT_ITEM=0');
    lines.push('FAILED_ITEMS=0');
    lines.push('');
    
    // Sync function
    lines.push('sync_item() {');
    lines.push('    local source="$1"');
    lines.push('    local dest="$2"');
    lines.push('    local name="$3"');
    lines.push('    local size="$4"');
    lines.push('    ');
    lines.push('    CURRENT_ITEM=$((CURRENT_ITEM + 1))');
    lines.push('    log_info "[$CURRENT_ITEM/$TOTAL_ITEMS] Syncing: $name (${size}GB)"');
    lines.push('    ');
    lines.push('    # Create destination directory');
    lines.push('    mkdir -p "$(dirname "$dest")"');
    lines.push('    ');
    lines.push('    # Perform rsync');
    lines.push('    if rsync $RSYNC_OPTIONS "$source/" "$dest/"; then');
    lines.push('        log_info "✅ Successfully synced: $name"');
    lines.push('        return 0');
    lines.push('    else');
    lines.push('        log_error "❌ Failed to sync: $name"');
    lines.push('        FAILED_ITEMS=$((FAILED_ITEMS + 1))');
    lines.push('        return 1');
    lines.push('    fi');
    lines.push('}');
    lines.push('');
    
    // Main sync operations
    lines.push('# Main sync operations');
    lines.push('log_info "Starting sync of $TOTAL_ITEMS items..."');
    lines.push('');
    
    // Group items by type for better organization
    const movieItems = items.filter(item => item.type.toLowerCase() === 'movie');
    const tvItems = items.filter(item => item.type.toLowerCase() === 'tv');
    const webtvItems = items.filter(item => item.type.toLowerCase() === 'webtv');
    const kiwixItems = items.filter(item => item.type.toLowerCase() === 'kiwix');
    const otherItems = items.filter(item => !['movie', 'tv', 'webtv', 'kiwix'].includes(item.type.toLowerCase()));


    
    // Movies section
    if (movieItems.length > 0) {
      lines.push('# Movies');
      lines.push('log_info "Syncing movies..."');
      for (const item of movieItems) {
        const destPath = join('$DESTINATION', 'movies', basename(item.nfs_path));
        lines.push(`sync_item "${item.nfs_path}" "${destPath}" "${item.name}" "${item.size_gb.toFixed(2)}"`);
      }
      lines.push('');
    }
    
    // TV Shows section
    if (tvItems.length > 0) {
      lines.push('# TV Shows');
      lines.push('log_info "Syncing TV shows..."');
      for (const item of tvItems) {
        const showBaseName = basename(item.nfs_path);

        // Check if specific seasons are defined
        if (item.seasons && item.seasons.length > 0) {
          // Sync specific seasons only
          lines.push(`# ${item.name} - Selected seasons: ${item.seasons.join(', ')}`);
          for (const seasonNumber of item.seasons) {
            const seasonPath = join(item.nfs_path, `Season ${seasonNumber.toString().padStart(2, '0')}`);
            const destPath = join('$DESTINATION', 'tv', showBaseName, `Season ${seasonNumber.toString().padStart(2, '0')}`);
            lines.push(`sync_item "${seasonPath}" "${destPath}" "${item.name} - Season ${seasonNumber}" "0"`);
          }
        } else {
          // Sync entire show (all seasons or no season structure)
          const destPath = join('$DESTINATION', 'tv', showBaseName);
          lines.push(`sync_item "${item.nfs_path}" "${destPath}" "${item.name}" "${item.size_gb.toFixed(2)}"`);
        }
      }
      lines.push('');
    }

    // WebTV Channels section
    if (webtvItems.length > 0) {
      lines.push('# WebTV Channels (Smart Selection Applied)');
      lines.push(`log_info "Syncing ${webtvItems.length} selected WebTV channels..."`);

      // Check if any item has WebTV selection info to show selection details
      const webtvSelectionInfo = webtvItems.find(item => item.webtv_selection);
      if (webtvSelectionInfo?.webtv_selection) {
        const selection = webtvSelectionInfo.webtv_selection;
        lines.push(`log_info "WebTV Selection: ${selection.selected_channels.length} channels selected (${selection.total_size_gb.toFixed(1)}GB), ${selection.channel_breakdown.excluded.length} excluded"`);
        if (selection.warnings.length > 0) {
          selection.warnings.forEach(warning => {
            lines.push(`log_warn "WebTV: ${warning}"`);
          });
        }
      }

      for (const item of webtvItems) {
        const channelBaseName = basename(item.nfs_path);
        const destChannelPath = join('$DESTINATION', 'webtv', channelBaseName);

        if (item.webtv_channel_info?.copy_mode === 'partial' && item.webtv_channel_info.selected_videos) {
          // Partial channel: copy individual video files
          const totalChannelSize = item.webtv_channel_info.total_channel_size_gb || 0;
          lines.push(`# ${item.name} - Partial selection (${item.webtv_channel_info.selected_videos.length} videos, ${item.size_gb.toFixed(2)}GB of ${totalChannelSize.toFixed(2)}GB total)`);
          lines.push(`mkdir -p "${destChannelPath}"`);

          for (const video of item.webtv_channel_info.selected_videos) {
            const videoDestPath = join(destChannelPath, video.name);
            lines.push(`sync_item "${video.path}" "${videoDestPath}" "${item.name}/${video.name}" "${video.size_gb.toFixed(2)}"`);
          }
        } else {
          // Required channel: copy entire directory
          lines.push(`# ${item.name} - ${item.webtv_channel_info?.is_required ? 'Required' : 'Optional'} channel (entire directory, ${item.size_gb.toFixed(2)}GB)`);
          lines.push(`sync_item "${item.nfs_path}" "${destChannelPath}" "${item.name}" "${item.size_gb.toFixed(2)}"`);
        }
      }
      lines.push('');
    }

    // Kiwix content section
    if (kiwixItems.length > 0) {
      lines.push('# Kiwix Content (Offline Educational Content)');
      lines.push('log_info "Downloading/updating Kiwix ZIM files..."');
      lines.push('');

      // Add Kiwix configuration variables
      if (this.config.kiwix_config) {
        lines.push('# Kiwix Configuration');
        lines.push(`KIWIX_DOWNLOAD_PATH="${this.config.kiwix_config.download_path}"`);
        lines.push(`KIWIX_PARALLEL_DOWNLOADS=${this.config.kiwix_config.parallel_downloads}`);
        lines.push(`KIWIX_RETRY_ATTEMPTS=${this.config.kiwix_config.retry_attempts}`);
        lines.push(`KIWIX_VERIFY_CHECKSUMS=${this.config.kiwix_config.verify_checksums ? 'true' : 'false'}`);
        lines.push('');

        // Add mirror URLs
        lines.push('# Kiwix Mirror URLs (in priority order)');
        const enabledMirrors = this.config.kiwix_config.mirrors
          .filter(mirror => mirror.enabled)
          .sort((a, b) => a.priority - b.priority);

        lines.push('KIWIX_MIRRORS=(');
        enabledMirrors.forEach(mirror => {
          lines.push(`    "${mirror.url}"`);
        });
        lines.push(')');
        lines.push('');
      }

      lines.push('# Function to download Kiwix content');
      lines.push('download_kiwix() {');
      lines.push('    log_info "🌐 Testing mirror speeds and selecting best mirror..."');
      lines.push('    ');
      lines.push('    # Create download directory if it doesn\'t exist');
      lines.push('    mkdir -p "$KIWIX_DOWNLOAD_PATH"');
      lines.push('    ');
      lines.push('    log_info "📥 Checking for updates and downloading ZIM files..."');
      lines.push('    ');

      // Add download commands for each Kiwix item
      for (const item of kiwixItems) {
        lines.push(`    # Download ${item.name} (${item.size_gb.toFixed(2)}GB)`);
        lines.push(`    log_info "Processing ${item.name}..."`);
        lines.push(`    ZIM_FILE="$KIWIX_DOWNLOAD_PATH/${item.name}.zim"`);
        lines.push('    ');
        lines.push('    # Check if file already exists and is up to date');
        lines.push('    if [ -f "$ZIM_FILE" ]; then');
        lines.push(`        log_info "File exists, checking if update needed..."`);
        lines.push('        # Add size/date checks here if needed');
        lines.push('    fi');
        lines.push('    ');
        lines.push('    # Download from best available mirror');
        lines.push('    DOWNLOAD_SUCCESS=false');
        lines.push('    for mirror in "${KIWIX_MIRRORS[@]}"; do');
        lines.push('        log_info "Trying mirror: $mirror"');
        lines.push(`        if wget -c -t "$KIWIX_RETRY_ATTEMPTS" -O "$ZIM_FILE" "$mirror/zim/${item.name}.zim"; then`);
        lines.push('            DOWNLOAD_SUCCESS=true');
        lines.push(`            log_info "✅ Successfully downloaded ${item.name}"`);
        lines.push('            break');
        lines.push('        else');
        lines.push(`            log_error "❌ Failed to download from $mirror"`);
        lines.push('        fi');
        lines.push('    done');
        lines.push('    ');
        lines.push('    if [ "$DOWNLOAD_SUCCESS" = false ]; then');
        lines.push(`        log_error "❌ Failed to download ${item.name} from all mirrors"`);
        lines.push('        FAILED_ITEMS=$((FAILED_ITEMS + 1))');
        lines.push('    fi');
        lines.push('    ');
      }

      lines.push('    log_info "✅ Kiwix download process complete"');
      lines.push('}');
      lines.push('');
      lines.push('# Execute Kiwix downloads');
      lines.push('download_kiwix');
      lines.push('');
    }

    // Other content section
    if (otherItems.length > 0) {
      lines.push('# Other Content');
      lines.push('log_info "Syncing other content..."');
      for (const item of otherItems) {
        const typeDir = item.type.toLowerCase() === 'games' ? 'games' : 'other';
        const destPath = join('$DESTINATION', typeDir, basename(item.nfs_path));
        lines.push(`sync_item "${item.nfs_path}" "${destPath}" "${item.name}" "${item.size_gb.toFixed(2)}"`);
      }
      lines.push('');
    }
    
    // Summary
    lines.push('# Summary');
    lines.push('log_info "Sync completed!"');
    lines.push('log_info "Total items processed: $TOTAL_ITEMS"');
    lines.push('log_info "Failed items: $FAILED_ITEMS"');
    lines.push('log_info "Successful items: $((TOTAL_ITEMS - FAILED_ITEMS))"');
    lines.push('');
    lines.push('if [ "$FAILED_ITEMS" -gt 0 ]; then');
    lines.push('    log_error "Some items failed to sync. Check the log above for details."');
    lines.push('    exit 1');
    lines.push('else');
    lines.push('    log_info "🎉 All items synced successfully!"');
    lines.push('fi');
    
    return lines.join('\n') + '\n';
  }

  /**
   * Generate a simple rsync script without advanced features
   */
  async exportSimple(
    analyses: ContentAnalysis[],
    outputPath: string,
    destination: string
  ): Promise<void> {
    const foundItems = analyses.filter(a => a.status === 'found' && a.size_gb > 0);
    
    const lines: string[] = [];
    lines.push('#!/bin/bash');
    lines.push('');
    lines.push('# Simple Media Collection Rsync Script');
    lines.push(`# Destination: ${destination}`);

    // Add WebTV selection info if available
    const webtvItems = foundItems.filter(a => a.type.toLowerCase() === 'webtv');
    const webtvSelectionInfo = webtvItems.find(item => item.webtv_selection);
    if (webtvSelectionInfo?.webtv_selection) {
      const selection = webtvSelectionInfo.webtv_selection;
      lines.push(`# WebTV Smart Selection: ${selection.selected_channels.length} channels selected, ${selection.channel_breakdown.excluded.length} excluded`);
    }

    lines.push('');
    
    for (const item of foundItems) {
      const typeDir = item.type.toLowerCase() === 'movie' ? 'movies' :
                     item.type.toLowerCase() === 'tv' ? 'tv' :
                     item.type.toLowerCase() === 'webtv' ? 'webtv' :
                     item.type.toLowerCase() === 'games' ? 'games' : 'other';

      // Handle TV shows with specific seasons
      if (item.type.toLowerCase() === 'tv' && item.seasons && item.seasons.length > 0) {
        // Sync specific seasons only
        lines.push(`# ${item.name} - Selected seasons: ${item.seasons.join(', ')} (${item.size_gb.toFixed(2)}GB total)`);
        for (const seasonNumber of item.seasons) {
          const showBaseName = basename(item.nfs_path);
          const seasonPath = join(item.nfs_path, `Season ${seasonNumber.toString().padStart(2, '0')}`);
          const destPath = join(destination, typeDir, showBaseName, `Season ${seasonNumber.toString().padStart(2, '0')}`);
          lines.push(`rsync ${this.config.rsync_config.options.join(' ')} "${seasonPath}/" "${destPath}/"`);
        }
        lines.push('');
      } else if (item.type.toLowerCase() === 'webtv' && item.webtv_channel_info?.copy_mode === 'partial' && item.webtv_channel_info.selected_videos) {
        // Handle WebTV partial channel selection
        const channelBaseName = basename(item.nfs_path);
        const destChannelPath = join(destination, typeDir, channelBaseName);
        const totalChannelSize = item.webtv_channel_info.total_channel_size_gb || 0;
        lines.push(`# ${item.name} - Partial selection (${item.webtv_channel_info.selected_videos.length} videos, ${item.size_gb.toFixed(2)}GB of ${totalChannelSize.toFixed(2)}GB total)`);
        lines.push(`mkdir -p "${destChannelPath}"`);

        for (const video of item.webtv_channel_info.selected_videos) {
          const videoDestPath = join(destChannelPath, video.name);
          lines.push(`rsync ${this.config.rsync_config.options.join(' ')} "${video.path}" "${videoDestPath}"`);
        }
        lines.push('');
      } else {
        // Sync entire item (movies, entire TV shows, entire WebTV channels, or other content)
        const destPath = join(destination, typeDir, basename(item.nfs_path));
        const channelInfo = item.webtv_channel_info?.is_required ? ' (Required)' : '';
        lines.push(`# ${item.name}${channelInfo} (${item.size_gb.toFixed(2)}GB)`);
        lines.push(`rsync ${this.config.rsync_config.options.join(' ')} "${item.nfs_path}/" "${destPath}/"`);
        lines.push('');
      }
    }
    
    const scriptContent = lines.join('\n');
    await writeFile(outputPath, scriptContent, 'utf-8');
    await chmod(outputPath, 0o755);
  }
}
